#! /usr/bin/perl -w

use strict;
use IO::File;
use File::Glob ':glob';
use Getopt::Long qw(GetOptions);

sub help ()
{
  print <<EOF;
Usage: $0 [OPTIONS] FILES

Reindent roughly the FILES.  A back up of the files is left.

- Normalize white spaces
- No open prace not alone on the line
  (except for try and catch, but this is not implemented yet).
- Factor some constructs
  - strcmp == 0 => STREQ
- Use libport headers when appropriate

Once reindent passed, you should use Emacs or similar to finish
the reindentation.
EOF
  exit 0;
}

sub fatal (@)
{
  print STDERR "$0: @_\n";
  exit 1;
}

=item C<update_file ($from, $to, [$force])>

Rename C<$from> as C<$to>, preserving C<$to> timestamp if it has not
changed, unless C<$force> is true (defaults to false).  Recognize
C<$to> = C<-> standing for C<STDIN>.  C<$from> is always
removed/renamed.

=cut

# &update_file ($FROM, $TO; $FORCE)
# ---------------------------------
sub update_file ($$;$)
{
  my ($from, $to, $force) = @_;
  $force = 0
    unless defined $force;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  use File::Compare;
  use File::Copy;

  if ($to eq '-')
    {
      my $in = new IO::File ("$from");
      my $out = new IO::File (">-");
      while ($_ = $in->getline)
	{
	  print $out $_;
	}
      $in->close;
      unlink ($from) || fatal "cannot remove $from: $!";
      return;
    }

  if (!$force && -f "$to" && compare ("$from", "$to") == 0)
    {
      # File didn't change, so don't update its mod time.
      unlink ($from)
	or fatal "cannot remove $from: $!";
      return
    }

  if (-f "$to")
    {
      # Back up and install the new one.
      move ("$to",  "$to$SIMPLE_BACKUP_SUFFIX")
	or fatal "cannot backup $to: $!";
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
  else
    {
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
}


# Location of the share directory.
my $share = 'share';

# The sed program to update old cite keys.
my $updater = '';

# contents ($FILE_NAME)
# ---------------------
sub contents ($)
{
  my ($file) = @_;
  local $/;			# Turn on slurp-mode.
  my $f = new IO::File "< $file";
  my $contents = $f->getline;
  $f->close;
  return $contents;
}

# Backup this FILE, return the back up file name.
sub backup ($)
{
  my ($from) = @_;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  my $to = "$from$SIMPLE_BACKUP_SUFFIX";
  use File::Copy;
  move ($from, $to)
    or die "cannot backup $from: $!";
  return $to;
}

# Remove all the parens.
sub strip_parens ($$)
{
  my ($inst, $in) = @_;
  $in =~ s/\(\s*//mg;
  $in =~ s/\s*\)//mg;
  return "$inst ($in)";
}

# Reindent this FILE.
sub reindent ($)
{
  my ($file) = @_;
  my $backup = backup ($file);

  $_ = contents ($backup);

  # Beware that \s includes \n and often does not do what we want.
  # Use [ \t] instead.


  ## -------- ##
  ## Spaces.  ##
  ## -------- ##

  # Trailing.
  s/[ \t]+$//gm;

  # Leading.
  while (s/^(\t*) {8}/$1\t/gm
	 || s/^(\t+) {1,7}\t/$1\t/gm)
    {
      next;
    }


  ## -------- ##
  ## Braces.  ##
  ## -------- ##

  # Trailing open brace followed by empty lines (common in Urbi).
  s(^([ \t]*)(.+\S)[ \t]*\{\n+)
   ($1$2\n$1\{\n)gm;

  # Exceptions are "do {" and "try {".
  s(\b(do|try)\s+{)($1 {)gsm;

  # An opening brace with comments.
  s(^([ \t]*)\{[ \t]*//[ \t]*)
   ($1\{\n$1  // )gm;


  ## ------------- ##
  ## Refactoring.  ##
  ## ------------- ##

  # strcmp (foo, bar) == 0 -> STREQ (foo, bar).
  s(strcmp *(\(.*?\))[ \t]*==[ \t]*0)
    (STREQ$1)gm;

  # if ((foo) && (bar)) -> if (foo && bar).
  s{(if|while)\s*\( *(\([\s\w\->=]+\)(\s*(&&|\|\|)\s*\([\s\w\->=]+\))*)\)}
   <&strip_parens($1, $2)>gme;

  # return needs no parens.
  s{return\s*\( *(([\s\w\->]|==)+) *\) *;}
   {return $1;}gm;

  # Use the traditional notation for pointers.
  s{\(\*(\w+)\)\.}
   {$1->}gm;

  ## ---------- ##
  ## Includes.  ##
  ## ---------- ##

  # include <stdio.h> -> <cstdio>.
  s((# *include) *<(stdio|stdlib|math|string).h>)
   ($1 <c$2>)gm;

  # <cstring> -> "libport/cstring"
  s(<cstring>)("libport/cstring")gm;

  # Update.
  my $out = new IO::File ">$file.new" or die;
  print $out $_;
  update_file "$file.new", $file;
}

# Parse ARGV, return the list of files to update.
sub parse_options ()
{
  use Getopt::Long;
  Getopt::Long::config ("bundling", "pass_through");
  Getopt::Long::GetOptions
    (
     'h|help'   => sub { help; },
    )
    or die;

  foreach my $arg (@ARGV)
    {
      if ($arg =~ /^-./)
	{
	  print STDERR "$0: unrecognized option `$arg'\n";
	  print STDERR "Try `$0 --help' for more information.\n";
	  exit (1);
	}
    }
  return @ARGV;
}

my @tex = parse_options ();
reindent ($_)
  foreach @tex;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
