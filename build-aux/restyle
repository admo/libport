#! /usr/bin/perl -w

use strict;
use IO::File;
use File::Glob ':glob';
use Getopt::Long qw(GetOptions);

sub help ()
{
  print <<EOF;
Usage: $0 [OPTIONS] FILES

Restyle roughly the FILES.  A back up of the files is left.

- Normalize white spaces
- No open brace not alone on the line
  (except for try and catch, but this is not implemented yet).
- Factor some constructs
  - strcmp == 0 => STREQ
- Use libport headers when appropriate

Once reindent passed, you should use Emacs or similar to finish
the reindentation.
EOF
  exit 0;
}

sub stderr (@)
{
  print STDERR "$0: @_\n";
}

sub fatal (@)
{
  stderr @_;
  exit 1;
}

=item C<update_file ($from, $to, [$force])>

Rename C<$from> as C<$to>, preserving C<$to> timestamp if it has not
changed, unless C<$force> is true (defaults to false).  Recognize
C<$to> = C<-> standing for C<STDIN>.  C<$from> is always
removed/renamed.

=cut

# &update_file ($FROM, $TO; $FORCE)
# ---------------------------------
sub update_file ($$;$)
{
  my ($from, $to, $force) = @_;
  $force = 0
    unless defined $force;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  use File::Compare;
  use File::Copy;

  if ($to eq '-')
    {
      my $in = new IO::File ("$from");
      my $out = new IO::File (">-");
      while ($_ = $in->getline)
	{
	  print $out $_;
	}
      $in->close;
      unlink ($from) || fatal "cannot remove $from: $!";
      return;
    }

  if (!$force && -f "$to" && compare ("$from", "$to") == 0)
    {
      # File didn't change, so don't update its mod time.
      unlink ($from)
	or fatal "cannot remove $from: $!";
      stderr "$to unchanged";
      return;
    }

  if (-f "$to")
    {
      # Back up and install the new one.
      move ("$to",  "$to$SIMPLE_BACKUP_SUFFIX")
	or fatal "cannot backup $to: $!";
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
  else
    {
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
  stderr "$to updated";
}


# Location of the share directory.
my $share = 'share';

# The sed program to update old cite keys.
my $updater = '';

# contents ($FILE_NAME)
# ---------------------
sub contents ($)
{
  my ($file) = @_;
  local $/;			# Turn on slurp-mode.
  my $f = new IO::File "< $file";
  my $contents = $f->getline;
  $f->close;
  return $contents;
}

# Backup this FILE, return the back up file name.
sub backup ($)
{
  my ($from) = @_;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  my $to = "$from$SIMPLE_BACKUP_SUFFIX";
  use File::Copy;
  move ($from, $to)
    or die "cannot backup $from: $!";
  return $to;
}

# Remove all the parens.
sub strip_parens ($$)
{
  my ($inst, $in) = @_;
  $in =~ s/\(\s*//mg;
  $in =~ s/\s*\)//mg;
  return "$inst ($in)";
}

# Handle the comments following a closing brace.
sub clear_closing_brace ($)
{
  my ($comment) = @_;
  # comments about namespaces are ok.
  $comment = ""
    unless $comment =~ m/namespace/;
  if ($comment)
    {
      return "} $comment";
    }
  else
    {
      return "}";
    }
}

# Rewrite multiple statements written on a single line.
sub one_stm_per_line($)
{
  $_ = shift;
  /^([ \t]*)([^;\n]+)\s*;/ or die;

  # Don't do anything if this is a for loop.
  return "$_" if $2 =~ /\bfor\b/;

  my $indent = $1;
  my $res = '';
  while (/^[ \t]*([^;\n]+)\s*;/)
    {
      $_ = $';
      $res .= "$indent$1;";
      if (m{^\s*/(/|\*)}) # The remaining is a comment, stop here.
        {
	  $res .= "$_";
	  last;
	}
      else
        {
	  $res .= "\n" unless /^\s*$/;
	}
    }
  return $res;
};

# Reindent this FILE.
sub reindent ($)
{
  my ($file) = @_;
  if (!-f $file)
    {
      stderr "$file is not a file, skipping it.";
      return 0;
    }
  my $backup = backup ($file);

  $_ = contents ($backup);

  # Beware that \s includes \n and often does not do what we want.
  # Use [ \t] instead.

  # Remove trailing whitespaces before doing anything else. This makes the
  # following regexps easier because they don't have to deal with these.
  s/[ \t]+$//gm;

  ## ------------ ##
  ## Indentation. ##
  ## ------------ ##

  # Match a simple statement.
  my $stm = '([^;\n]+)\s*;';

  # Match if(condition) statement; in simple cases.
  my $if_stm = 'if\s*\(([^()]+)\)[ \t]*' . $stm;

  # Rewrite if written on a single line on two lines.
  # if (condition) something(); else doit();  ->  if (condition)
  #                                                 something();
  #                                               else
  #                                                 doit();
  # The condition must not have parenthesis since we can't match them
  # properly.
  s{^([ \t]*)${if_stm}[ \t]*else[ \t]*$stm}
   {$1if ($2)\n$1  $3;\n$1else\n$1  $4;}gm;

  # Same thing but without the else-part (can we factor the two cases?)
  s{^([ \t]*)$if_stm}
   {$1if ($2)\n$1  $3;}gm;

  # Same thing but only the else/if-part is on a single line.
  s{^([ \t]*)else\s+$if_stm}
   {$1else if ($2)\n$1  $3;}gm;

  # Same thing but only the else-part is on a single line.
  s{^([ \t]*)else[ \t]*$stm}
   {$1else\n$1  $2;}gm;

  my $case = '(case\s+([^:]+)|default)\s*:\s*';

  # Rewrite cases written on a single line on three lines.
  # case SOME_CASE: foo(); break;  ->  case SOME_CASE:
  #                                      foo();
  #                                      break;
  # Handle default cases and cases terminated using return instead of break.
  s{^([ \t]*)$case(break|return[^;]*)\s*;}
   {$1$2:\n$1  $4;}gm;

  # Same thing but with a foo() statement as in the example above.
  s{^([ \t]*)$case$stm\s*(break|return[^;]*)\s*;}
   {$1$2:\n$1  $4;\n$1  $5;}gm;

  # Inline methods written on a single line.
  # eg:  virtual int* doit(int* arg1, int* arg2 )  { return arg1 + arg2; };
  # is rewritten in:
  #      virtual int* doit (int* arg1, int* arg2 )
  #      {
  #        return arg1 + arg2;
  #      }
  s<^([ \t]*)([\w \t*&:\<\>]*?)\s*\(\s*([^)]*)\s*\)[ \t]*\{\s*([^{}]+)\s*\}(\s*;)?>
   <$1$2 ($3)\n$1\{\n$1  $4\n$1\}>gm;

  # Multiple statements on a single line.
  # The first statement must not contain { or , because in this case it's
  # usually not a statement, eg:
  # class Foo {
  #   void bar () { ...; };
  # };
  s<^([ \t]*)([^{,;\n]+)\s*;([ \t]*([^;\n]+)\s*;)+>
   <&one_stm_per_line($&)>gme;

  ## ---------- ##
  ## Comments.  ##
  ## ---------- ##

  # Some comments are useless, such as tagging the end of a syntactic
  # construct.  This does not apply to those ending a namespace.
  s<}[\t ]*(//.*)><&clear_closing_brace($1)>gme;


  ## ------------- ##
  ## Expressions.  ##
  ## ------------- ##

  my $cast = '\(\s*([\w<>: ]+)\s*(\*+)\s*\)\s*';

  # 0 has all the pointer types.
  s{${cast}0}{0}gm;

  # Use static_cast instead of old-style C cast for malloc's return.
  # (type*) malloc(args) -> static_cast<type*> (malloc (args))
  # It might fail in this kind of case:
  # -  int* p = (int*) malloc (sizeof(int)
  # -                         + 42);
  # +  int* p = static_cast<int*> (malloc (sizeof(int))
  # +  			     + 42);
  s{$cast(m|c|re)alloc\s*\((.*)\)}
   {static_cast<$1$2> ($3alloc ($4))}gm;

  # Use static_cast also for memmove/memcpy 2nd argument.
  s{(memmove|memcpy)\s*\(([^,]*),\s*$cast([^(),]*)\s*,}
   {$1 ($2, static_cast<$3$4> ($5),};

  # Use static_cast also for realloc/memmove/memcpy 1st argument.
  s{(realloc|memmove|memcpy)\s*\(\s*$cast([^(),]*)\s*,}
   {$1 (static_cast<$2$3> ($4),}gm;

  ## -------- ##
  ## Braces.  ##
  ## -------- ##

  # Trailing open brace followed by empty lines (common in Urbi).
  # The open brace mustn't be preceded by a backslash (Doxygen syntax).
  s(^([ \t]*)(.+\S)[ \t]*[^\\\n]\{\n+)
   ($1$2\n$1\{\n)gm;

  # Exceptions are "do {" and "try {".
  s(\b(do|try)\s+{)($1 {)gsm;

  # An opening brace followed with comments.
  s(^([ \t]*)\{[ \t]*//[ \t]*)
   ($1\{\n$1  // )gm;


  ## ------------- ##
  ## Refactoring.  ##
  ## ------------- ##

  # strcmp (foo, bar) == 0 -> STREQ (foo, bar).
  s(strcmp[ \t]*(\(.*?\))[ \t]*==[ \t]*0)
    (STREQ$1)gm;

  # !strcmp (foo, bar) -> STREQ (foo, bar).
  s(!strcmp[ \t]*(\(.*?\)))
    (STREQ$1)gm;

  # if ((foo) && (bar)) -> if (foo && bar).
  s{(if|while)\s*\(\s*(\([\s\w\-:<>=!]+\)(\s*(&&|\|\|)\s*\([\s\w\-:<>=!]+\))*)\s*\)}
   <&strip_parens($1, $2)>gme;

  # return needs no parens.
  # This used to not work properly on examples such as:
  # -       return (*retr)->getUObject();
  # +       return *retr)->getUObject(;
  # That's why we're changing the return only if has no other parens.
  # We really need to write a function that check that the first
  # and last parens do match together.
  s{return\s*\(\s*([^()]*?)\s*\)\s*;}
   {return $1;}gm;

  # Remove useless yet dangerous default cases at the end of a switch, eg:
  # switch (...)
  # {
  #   case FOO: ...; break;
  #   [...]
  #   default: break;  <-- Remove this line
  # }
  # Because the compiler won't warn use that some cases aren't handled in the
  # switch. If this was intended, it should have been commented, eg:
  #   default: /* skip */ break;
  # and this regexp wouldn't match.
  s/^[ \t]*default\s*:\s*break\s*;\n?(\s*})/$1/gm;

  # i++; -> ++i;
  s{^([ \t]*)([-\w:<>]+)\s*(\+\+|--)\s*([;)])}{$1$3$2$4}gm;

  # for(...; ...; i++) -> for(...; ...; ++i)
  s{;[ \t]*([-\w:<>]+)\s*(\+\+|--)\s*([;)])}{; $2$1$3}gm;


  ## ---------- ##
  ## Includes.  ##
  ## ---------- ##

  # include <stdio.h> -> <cstdio>.
  s{(# *include) *<(stdio|stdlib|math|string).h>}
   {$1 <c$2>}gm;

  # include <cstring> -> "libport/cstring"
  s{(# *include) *<(cstring|cstdio|sys/stat.h)>}
   {$1 "libport/$2"}gm;


  ## -------- ##
  ## Spaces.  ##
  ## -------- ##

  # Trailing. Again in case the above regexps added some.
  s/[ \t]+$//gm;

  # Leading.
  while (s/^(\t*) {8}/$1\t/gm
	 || s/^(\t+) {1,7}\t/$1\t/gm)
    {
      next;
    }


  ## ----------------- ##
  ## Update if needed. ##
  ## ----------------- ##

  my $out = new IO::File ">$file.new" or die;
  print $out $_;
  update_file "$file.new", $file;
  return 1
}

# Parse ARGV, return the list of files to update.
sub parse_options ()
{
  use Getopt::Long;
  Getopt::Long::config ("bundling", "pass_through");
  Getopt::Long::GetOptions
    (
     'h|help'   => sub { help; },
    )
    or die;

  foreach my $arg (@ARGV)
    {
      if ($arg =~ /^-./)
	{
	  print STDERR "$0: unrecognized option `$arg'\n";
	  print STDERR "Try `$0 --help' for more information.\n";
	  exit (1);
	}
    }
  return @ARGV;
}

my @tex = parse_options ();
help if ($#tex == -1);
reindent ($_)
  foreach @tex;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
### Vim modelines:
## vi: set noexpandtab:
