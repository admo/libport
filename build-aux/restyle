#! /usr/bin/perl -w

use strict;
use IO::File;
use File::Glob ':glob';
use Getopt::Long qw(GetOptions);

sub help ()
{
  print <<EOF;
Usage: $0 [OPTIONS] FILES

Restyle roughly the FILES.  A back up of the files is left.

- Normalize white spaces
- No open brace not alone on the line
  (except for try and catch, but this is not implemented yet).
- Factor some constructs
  - strcmp == 0 => STREQ
- Use libport headers when appropriate

Once reindent passed, you should use Emacs or similar to finish
the reindentation.
EOF
  exit 0;
}

sub stderr (@)
{
  print STDERR "$0: @_\n";
}

sub fatal (@)
{
  stderr @_;
  exit 1;
}

=item C<update_file ($from, $to, [$force])>

Rename C<$from> as C<$to>, preserving C<$to> timestamp if it has not
changed, unless C<$force> is true (defaults to false).  Recognize
C<$to> = C<-> standing for C<STDIN>.  C<$from> is always
removed/renamed.

=cut

# &update_file ($FROM, $TO; $FORCE)
# ---------------------------------
sub update_file ($$;$)
{
  my ($from, $to, $force) = @_;
  $force = 0
    unless defined $force;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  use File::Compare;
  use File::Copy;

  if ($to eq '-')
    {
      my $in = new IO::File ("$from");
      my $out = new IO::File (">-");
      while ($_ = $in->getline)
	{
	  print $out $_;
	}
      $in->close;
      unlink ($from) || fatal "cannot remove $from: $!";
      return;
    }

  if (!$force && -f "$to" && compare ("$from", "$to") == 0)
    {
      # File didn't change, so don't update its mod time.
      unlink ($from)
	or fatal "cannot remove $from: $!";
      stderr "$to unchanged";
      return;
    }

  if (-f "$to")
    {
      # Back up and install the new one.
      move ("$to",  "$to$SIMPLE_BACKUP_SUFFIX")
	or fatal "cannot backup $to: $!";
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
  else
    {
      move ("$from", "$to")
	or fatal "cannot rename $from as $to: $!";
    }
  stderr "$to updated";
}


# Location of the share directory.
my $share = 'share';

# The sed program to update old cite keys.
my $updater = '';

# contents ($FILE_NAME)
# ---------------------
sub contents ($)
{
  my ($file) = @_;
  local $/;			# Turn on slurp-mode.
  my $f = new IO::File "< $file";
  my $contents = $f->getline;
  $f->close;
  return $contents;
}

# Backup this FILE, return the back up file name.
sub backup ($)
{
  my ($from) = @_;
  my $SIMPLE_BACKUP_SUFFIX = $ENV{'SIMPLE_BACKUP_SUFFIX'} || '~';
  my $to = "$from$SIMPLE_BACKUP_SUFFIX";
  use File::Copy;
  move ($from, $to)
    or die "cannot backup $from: $!";
  return $to;
}

# Remove all the parens.
sub strip_parens ($$)
{
  my ($inst, $in) = @_;
  $in =~ s/\(\s*//mg;
  $in =~ s/\s*\)//mg;
  return "$inst ($in)";
}

# Handle the comments following a closing brace.
sub clear_closing_brace ($)
{
  my ($comment) = @_;
  # comments about namespaces are ok.
  $comment = ""
    unless $comment =~ m/namespace/;
  if ($comment)
    {
      return "} $comment";
    }
  else
    {
      return "}";
    }
}

# Reindent this FILE.
sub reindent ($)
{
  my ($file) = @_;
  if (!-f $file)
    {
      stderr "$file is not a file, skipping it.";
      return 0;
    }
  my $backup = backup ($file);

  $_ = contents ($backup);

  # Beware that \s includes \n and often does not do what we want.
  # Use [ \t] instead.


  ## -------- ##
  ## Spaces.  ##
  ## -------- ##

  # Trailing.
  s/[ \t]+$//gm;

  # Leading.
  while (s/^(\t*) {8}/$1\t/gm
	 || s/^(\t+) {1,7}\t/$1\t/gm)
    {
      next;
    }


  ## ---------- ##
  ## Comments.  ##
  ## ---------- ##

  # Some comments are useless, such as tagging the end of a syntactic
  # construct.  This does not apply to those ending a namespace.
  s<}[\t ]*(//.*)><&clear_closing_brace($1)>gme;


  ## ------------- ##
  ## Expressions.  ##
  ## ------------- ##

  my $cast = '\(\s*(\w+)\s*(\*+)\s*\)\s*';

  # 0 has all the pointer types.
  s{${cast}0}{0}gm;

  # Use static_cast instead of old-style C cast for malloc's return.
  # (type*) malloc(args) -> static_cast<type*> (malloc (args))
  # It might fail in this kind of case:
  # -  int* p = (int*) malloc (sizeof(int)
  # -                         + 42);
  # +  int* p = static_cast<int*> (malloc (sizeof(int))
  # +  			     + 42);
  s{$cast(m|c|re)alloc\s*\((.*)\)}
   {static_cast<$1$2> ($3alloc ($4))}gm;

  # Use static_cast also for memmove/memcpy 2nd argument.
  s{(memmove|memcpy)\s*\(([^,]*),\s*$cast([^(),]*)\s*,}
   {$1 ($2, static_cast<$3$4> ($5),};

  # Use static_cast also for realloc/memmove/memcpy 1st argument.
  s{(realloc|memmove|memcpy)\s*\(\s*$cast([^(),]*)\s*,}
   {$1 (static_cast<$2$3> ($4),}gm;

  ## -------- ##
  ## Braces.  ##
  ## -------- ##

  # Trailing open brace followed by empty lines (common in Urbi).
  s(^([ \t]*)(.+\S)[ \t]*\{\n+)
   ($1$2\n$1\{\n)gm;

  # Exceptions are "do {" and "try {".
  s(\b(do|try)\s+{)($1 {)gsm;

  # An opening brace with comments.
  s(^([ \t]*)\{[ \t]*//[ \t]*)
   ($1\{\n$1  // )gm;


  ## ------------- ##
  ## Refactoring.  ##
  ## ------------- ##

  # strcmp (foo, bar) == 0 -> STREQ (foo, bar).
  s(strcmp *(\(.*?\))[ \t]*==[ \t]*0)
    (STREQ$1)gm;

  # !strcmp (foo, bar) -> STREQ (foo, bar).
  s(!strcmp *(\(.*?\)))
    (STREQ$1)gm;

  # if ((foo) && (bar)) -> if (foo && bar).
  s{(if|while)\s*\( *(\([\s\w\->=]+\)(\s*(&&|\|\|)\s*\([\s\w\->=]+\))*)\)}
   <&strip_parens($1, $2)>gme;

  # return needs no parens.
  # This used to not work properly on examples such as:
  # -       return (*retr)->getUObject();
  # +       return *retr)->getUObject(;
  # That's why we're changing the return only if has no other parens.
  # We really need to write a function that check that the first
  # and last parens do match together.
  s{return\s*\(\s*([^()]*?)\s*\)\s*;}
   {return $1;}gm;


  ## ---------- ##
  ## Includes.  ##
  ## ---------- ##

  # include <stdio.h> -> <cstdio>.
  s{(# *include) *<(stdio|stdlib|math|string).h>}
   {$1 <c$2>}gm;

  # include <cstring> -> "libport/cstring"
  s{(# *include) *<(cstring|cstdio|sys/stat.h)>}
   {$1 "libport/$2"}gm;

  # Update if needed.
  my $out = new IO::File ">$file.new" or die;
  print $out $_;
  update_file "$file.new", $file;
  return 1
}

# Parse ARGV, return the list of files to update.
sub parse_options ()
{
  use Getopt::Long;
  Getopt::Long::config ("bundling", "pass_through");
  Getopt::Long::GetOptions
    (
     'h|help'   => sub { help; },
    )
    or die;

  foreach my $arg (@ARGV)
    {
      if ($arg =~ /^-./)
	{
	  print STDERR "$0: unrecognized option `$arg'\n";
	  print STDERR "Try `$0 --help' for more information.\n";
	  exit (1);
	}
    }
  return @ARGV;
}

my @tex = parse_options ();
help if ($#tex == -1);
reindent ($_)
  foreach @tex;

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
### Vim modelines:
## vi: set noexpandtab:
