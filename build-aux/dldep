#!/usr/bin/env ruby
##
## dldep: This file is part of libport.
## Copyright (C) Gostai S.A.S., 2006-2008.
##
## This software is provided "as is" without warranty of any kind,
## either expressed or implied, including but not limited to the
## implied warranties of fitness for a particular purpose.
##
## See the LICENSE file for more information.
## For comments, bug reports and feedback: http://www.urbiforge.com
##

require 'fileutils'
require 'rbconfig'

ME = File.basename($0)

$status = 0

def usage
  STDERR.puts <<EOF
usage: #{ME} binary [destdir]

This script print on the standard output the list of dependency
dynamic libraries of the binary file given as primary argument. If a
directory is given as second argument it copies the libraries in it.
EOF
end

# List of dynamic libraries that we never want to ship.
# NOTE for windows:
#   If a dll is present on a Windows XP Pro/Vista fresh installation, I add it
#   to the list. Use case insensitive name.
EXCLUDE = [
           # Win32
           'iphlpapi.dll',
           'advapi32.dll',
           'kernel32.dll',
           'rpcrt4.dll',
           'secur32.dll',
           'user32.dll',
           'gdi32.dll',
           'ws2_32.dll',
           'ws2help.dll',
           'wsock32.dll',
           'ole32.dll',
           'comdlg32.dll',
           'shlwapi.dll',
           'comctl32.dll',
           'shell32.dll',
           'imm32.dll',
           'oleaut32.dll',
           'winmm.dll',
           'ntdll.dll',
          ]

# We patch basename on windows because the default implementation
# return '\foo\file.txt' for 'c:\foo\file.txt' instead of 'file.txt'.
if Config::CONFIG['host_os'] =~ /cygwin/
  class File
    class << self
      alias_method :orig_basename, :basename
      def basename(file)
        file.sub(/^.*[\\\/]/, '')
      end
    end
  end # end File
end

def fatal(msg)
  STDERR.puts "#{ME}: fatal: #{msg}"
  exit 2
end

def warn(msg)
  STDERR.puts "#{ME}: warning: #{msg}"
end

def info(msg)
  STDERR.puts "#{ME}: info: #{msg}"
end

def error(msg)
  STDERR.puts "#{ME}: error: #{msg}"
  $status = 1
end

# Returns an array of value of this form:
# 1) file name of the shared library ; nil if parse error
# 2) full path name of the shared library ; nil if not found
# 3) address ; nil if not found
def ldd_parse(line)
  addr = nil
  if line =~ /^(\S+?)\s+=>\s+(.*)$/
    file = $1
    rest = $2
    case rest
    when /not found/
      path = nil
    when /(\S+?)\s*\((0x[0-9a-fA-F]+)\)/
      path = $1
      addr = $2
    else
      file = nil
    end
  else
    file = nil
  end
  [ file, path, addr ]
end

# Return an array of dependency libraries file name. Use ldd.
def ldd(bin)
  r = []
  `ldd #{bin}`.each do |line|
    line.strip!
    file, path, addr = ldd_parse(line)
    if file
      if path
        # Check for excluded libraries.
        if EXCLUDE.include?(File.basename(line))
          info("exclude '#{path}'")
        else
          r << path
        end
      else
        error "cannot find '#{file}'"
      end
    else
      warn "cannot parse`#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name. Use cygcheck.exe.
def cygcheck(bin)
  binBasename = File.basename(bin)
  r = []
  `cygcheck.exe #{bin}`.each do |line|
    line.strip!
    # Does it looks like a windows path?
    case line
    when /^([a-zA-Z]:[\/\\])?.*?([\/\\].*?)+$/
      # Exclude the binary name.
      next if File.basename(line) == binBasename
      # Check for excluded libraries.
      if EXCLUDE.include?(File.basename(line).downcase)
        info("exclude '#{line}'")
      else
        r << line
      end
    when /^Error: could not find (.*)$/
      error "cannot find '#$1'"
    else
      warn "cannot parse `#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name. Use otool -L.
def otool_L(bin)
  r = []
  `otool -L #{bin}`.each do |line|
    line.strip!
    # Exclude the binary name.
    next if line == "#{bin}:"
    # $1: path name
    # $2: compatibility version
    # $3: current version
    if line =~ /^(\S+)\s\(compatibility version ([\d.]+), current version ([\d.]+)\)$/
      path = $1
      # Check for excluded libraries.
      if EXCLUDE.include?(File.basename(path))
        info("exclude '#{path}'")
      else
    	r << path
      end
    else
      warn "cannot parse `#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name.
# Use the appropriate function for the OS running this command.
def dldep(bin)
  os = Config::CONFIG['host_os']
  case os
  when /linux/
    ldd(bin)
  when /cygwin/
    cygcheck(bin)
  when /darwin/
    otool_L(bin)
  else
    fatal "unsupported OS '#{os}'"
  end
end

# Copy the array of file _files_ to directory _dest_
def copy(files, dest)
  fatal "not a directory `#{dest}'" unless File.directory?(dest)
  r = FileUtils.cp(files, dest)
  r.each { |x| puts "#{x} -> #{dest}" }
  error("some file may not have been copied") if r.size != deps.size
rescue Errno::ENOENT => ex
  error(ex.to_s)
end

# Check that all the files exists.
def files_exists?(files)
  files.each do |x|
    error("files does not exist - #{x}") unless File.exists? x
  end
end

# ==== #
# Main #
# ==== #
if $0 == __FILE__

  if ARGV.empty? or ARGV.size > 2
    usage()
    exit 1
  end

  binFile = ARGV.first

  deps = dldep(binFile)
  files_exists? deps
  deps.each { |x| puts "#{x}" }

  if ARGV.size > 1
    dest = ARGV[1]
    info "Copying files to '#{dest}' ..."
    copy(deps, dest)
  end

  exit $status
end
