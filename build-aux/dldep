#!/usr/bin/env ruby
##
## dldep: This file is part of libport.
## Copyright (C) Gostai S.A.S., 2006-2008.
##
## This software is provided "as is" without warranty of any kind,
## either expressed or implied, including but not limited to the
## implied warranties of fitness for a particular purpose.
##
## See the LICENSE file for more information.
## For comments, bug reports and feedback: http://www.urbiforge.com
##

require 'pathname'
require 'fileutils'
require 'rbconfig'

ME = File.basename($0)

$status = 0

# List of dynamic libraries that we never want to ship. The test used is case
# insensitive.
# NOTE for windows:
#   If a dll is present on a Windows XP Pro/Vista fresh installation, I add it
#   to the list.
EXCLUDE = [
           # Win32
           'iphlpapi.dll',
           'advapi32.dll',
           'kernel32.dll',
           'rpcrt4.dll',
           'secur32.dll',
           'user32.dll',
           'gdi32.dll',
           'ws2_32.dll',
           'ws2help.dll',
           'wsock32.dll',
           'ole32.dll',
           'comdlg32.dll',
           'shlwapi.dll',
           'comctl32.dll',
           'shell32.dll',
           'imm32.dll',
           'oleaut32.dll',
           'winmm.dll',
           'ntdll.dll',
          ]
# Returns whether _filename_ is included in the EXCLUDE list.
def EXCLUDE.has?(filename)
  find { |x| x.casecmp(filename).zero? }
end

# Print the excluded file list to _io_.
def EXCLUDE.print(io = STDOUT)
  each { |x| io.puts x }
end

# We patch basename on windows because the default implementation
# return '\foo\file.txt' for 'c:\foo\file.txt' instead of 'file.txt'.
if Config::CONFIG['host_os'] =~ /cygwin/
  class File
    class << self
      alias_method :orig_basename, :basename
      def basename(file)
        file.sub(/^.*[\\\/]/, '')
      end
    end
  end # end File
end

def fatal(msg)
  STDERR.puts "#{ME}: fatal: #{msg}"
  exit 2
end

def warn(msg)
  STDERR.puts "#{ME}: warning: #{msg}"
end

def info(msg)
  STDERR.puts "#{ME}: info: #{msg}"
end

def error(msg)
  STDERR.puts "#{ME}: error: #{msg}"
  $status = 1
end

# Returns an array of value of this form:
# 1) file name of the shared library ; nil if parse error
# 2) full path name of the shared library ; nil if not found
# 3) address ; nil if not found
def ldd_parse(line)
  addr = nil
  if line =~ /^(\S+?)\s+=>\s+(.*)$/
    file = $1
    rest = $2
    case rest
    when /not found/
      path = nil
    when /(\S+?)\s*\((0x[0-9a-fA-F]+)\)/
      path = $1
      addr = $2
    else
      file = nil
    end
  else
    file = nil
  end
  [ file, path, addr ]
end

# Return an array of dependency libraries file name. Use ldd.
def ldd(bin)
  r = []
  `ldd #{bin}`.each do |line|
    line.strip!
    file, path, addr = ldd_parse(line)
    if file
      if path
        r << path
      else
        error "cannot find '#{file}'"
      end
    else
      warn "cannot parse`#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name. Use cygcheck.exe.
def cygcheck(bin)
  binBasename = File.basename(bin)
  r = []
  `cygcheck.exe #{bin}`.each do |line|
    line.strip!
    # Does it looks like a windows path?
    case line
    when /^([a-zA-Z]:[\/\\])?.*?([\/\\].*?)+$/
      # Exclude the binary name.
      next if File.basename(line) == binBasename
      r << line
    when /^Error: could not find (.*)$/
      error "cannot find '#$1'"
    else
      warn "cannot parse `#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name. Use otool -L.
def otool_L(bin)
  r = []
  `otool -L #{bin}`.each do |line|
    line.strip!
    # Exclude the binary name.
    next if line == "#{bin}:"
    # $1: path name
    # $2: compatibility version
    # $3: current version
    if line =~ /^(\S+)\s\(compatibility version ([\d.]+), current version ([\d.]+)\)$/
      r << $1
    else
      warn "cannot parse `#{line}'"
    end
  end
  r
end

# Return an array of dependency libraries file name.
# Use the appropriate function for the OS running this command.
def dldep(bin)
  os = Config::CONFIG['host_os']
  l = (case os
       when /linux/
         ldd(bin)
       when /cygwin/
         cygcheck(bin)
       when /darwin/
         otool_L(bin)
       else
         fatal "unsupported OS '#{os}'"
       end)
  unless $?.exitstatus.zero?
    fatal "The underneath otool exited with non-zero status."
  end
  # Check for excluded libraries.
  l.reject do |x|
    if EXCLUDE.has?(File.basename(x))
      info("exclude '#{x}'")
      true
    else
      false
    end
  end
end

# Copy the array of file _files_ to directory _dest_
def copy(files, dest)
  path = Pathname.new(dest)
  path.mkpath
  r = FileUtils.cp(files, path.to_s)
  r.each { |x| puts "#{x} -> #{path}" }
  error("some file may not have been copied") if r.size != files.size
rescue Errno::ENOENT => ex
  error(ex.to_s)
end

# Check that all the files exists.
def files_exists?(files)
  files.each do |x|
    error("files does not exist - #{x}") unless File.exists? x
  end
end

# ==== #
# Main #
# ==== #
if $0 == __FILE__

  require 'optparse'

  $output = '-'
  optparser = OptionParser.new do |op|

    op.banner = <<EOF
usage: #{ME} [options] binary [destdir]

This script print on the standard output the list of dependency
dynamic libraries of the binary file given as primary argument. If a
directory is given as second argument it copies the libraries in it.
EOF
    op.summary_indent = '  '
    op.summary_width = 25

    op.separator ''
    op.separator 'Options:'

    op.on('-e', '--exclude [FILE]',
          'Add FILE to the excluded file list. Maybe used several times. ' +
          'No argument for the list.') do |path|
      if path.nil?
        EXCLUDE.print
        exit 0
      else
        EXCLUDE << path
      end
    end

    op.on('-o', '--output FILE',
          'Output list to FILE instead of standard output.') do |path|
      $output = path
    end

    op.on_tail('-h', '--help', 'Show this message.') do
      puts op
      exit 0
    end
  end

  optparser.parse!(ARGV)

  if ARGV.empty? or ARGV.size > 2
    puts optparser
    exit 1
  end

  binFile = ARGV.first

  deps = dldep(binFile)
  files_exists? deps
  if $output == '-'
    io = STDOUT
  else
    io = File.open($output, 'w')
  end
  deps.each { |x| io.puts x }
  io.close

  if ARGV.size > 1
    dest = ARGV[1]
    info "Copying files to '#{dest}' ..."
    copy(deps, dest)
  end

  exit $status
end
