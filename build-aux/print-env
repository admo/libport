#! /usr/bin/perl -w

use strict;
use English;

=head1 NAME

print-env - print the environment in a human and sh readable maner.

=head1 SYNOPSIS

  print-env [OPTIONS...]

=head1 OPTIONS

General options:

=over 4

=item B<-i>, B<--ignore>=I<pattern>

Do not report variables that match the Perl regular expression
^I<pattern>$.

=item B<-I>, B<--ignore-standard>

Ignore some standard, uninteresting, variables.

=item B<-h>, B<--help>

Display this message and exit.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

=cut

# Variables to ignore.
my @ignore = ();

# Variables we don't care about.
my @ignore_standard =
  qw{
    as_nl
    Apple_PubSub.*
    CCACHE_.*
    CVS_.*
    DBUS_.*
    DISPLAY
    EDITOR
    EMAIL
    FULLNAME
    HOME
    LANG
    LANGUAGE
    LC_.*
    LOGNAME
    MANPATH
    MAKEFLAGS
    MAKELEVEL
    MAKEOVERRIDES
    MFLAGS
    OLDPWD
    PAGER
    PYTHONPATH
    SECURITYSESSIONID
    SHELL
    SHLVL
    SSH_AUTH_SOCK
    TERM
    TERM_.*
    TEXI2DVI_.*
    TMPDIR
    USER
    VISUAL
    _
    __CF_USER_.*
  };

# Verbosity level.
my $verbose = 1;

=head1 FUNCTIONS

=over 4

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  print STDERR "$0: ", @message
    if $level <= $verbose;
}


sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Portable instrumentation",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

######################################################################

sub getopt ()
{
  use Getopt::Long;

  my %option = (
    "h|help"             => sub { help ($verbose) },
    "i|ignore=s"         => \@ignore,
    "I|ignore-standard"  => sub { push @ignore, @ignore_standard },
    "q|quiet"            => sub { --$verbose },
    "v|verbose+"         => \$verbose,
    );
  Getopt::Long::Configure ("bundling");
  GetOptions (%option)
    or exit 1;
}


######################################################################

=item C<shellescape($str)>

Return C<$str> properly escaped for a regular Bourne shell.  Avoid
useless quotes to produce a readable result.  Keep sync with the copy
in instrument.

This is insufficient.  We actually need to have the result "eval"'ed.

=cut

sub shellescape($)
{
  my ($str) = @_;
  if ($str =~ m([^-=+_/.[:alnum:]]))
    {
      $str =~ s,[\\'],'\\$&',g;
      $str = "'$str'";
    }
  return $str;
}

## ------ ##
## Main.  ##
## ------ ##

getopt;

my $ignore = '^(' . join ('|', @ignore) . ')$';
verbose 2, "ignore pattern: $ignore\n";
for my $v (sort keys %ENV)
{
  printf "%s=%s\n", $v, shellescape $ENV{$v}
    unless $v =~ m/$ignore/o;
}


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
