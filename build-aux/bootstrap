#! /bin/sh

##
## bootstrap: This file is part of build-aux.
## Copyright (C) Gostai S.A.S., 2006-2008.
##
## This software is provided "as is" without warranty of any kind,
## either expressed or implied, including but not limited to the
## implied warranties of fitness for a particular purpose.
##
## See the LICENSE file for more information.
## For comments, bug reports and feedback: http://www.urbiforge.com
##

# Required version of these tools.
: ${autoconf_prereq=2.61}
: ${automake_prereq=1.10}
: ${libtool_prereq=2.2.6}

pid=$$

if test "X$TERM" != Xdumb                       \
    && test -t 1 2>/dev/null                    \
    && tput bold 1 >/dev/null 2>&1              \
    && tput setaf 1 >/dev/null 2>&1		\
    && tput sgr0 >/dev/null 2>&1; then
  blu=$(tput setaf 4)
  grn=$(tput setaf 2)
  lgn=$(tput bold)$(tput setaf 2)
  red=$(tput setaf 1)
  ylw=$(tput setaf 3)
  std=$(tput sgr0)
fi

usage ()
{
  cat <<EOF
Usage: $0 [OPTIONS]

Bootstrap the GNU Build system using autoreconf.

See also <URL:https://core.gostai.com/projects/common/wiki/LibPort>.

This file and git-my-update use \`~/.libport/bootstrap.cfg' and
\`externals/bootstrap.cfg' to describe what's to be done.  For
backward compatibility, \`.externals' is also supported.

The syntax is dummy and made to be easily sed-parsable.  It supports
the following directives (which must be in column 0, anything else is
silently ignored):

external: [DIR-NAME ->] REPO-NAME
  Install REPO-NAME as submodule, and update it when needed.
  E.g. \`external: libport'.
       \`external: tests -> urbivalid'.

keep: FILE
  Files that should be kept accross Autotools installation.
  E.g., \`keep: INSTALL' if we don't want Autoconf's.

link: FROM -> TO
  Install a link named FROM that points to TO.
  E.g. \`link: include/libport -> libport/include/libport'.

links: (copy|symbolic)+
  Specify how \`link:' primitives should be handled.  People using
  src = build should use copies.  People who need to edit the submodules
  must not use copies.  So

     ## ------------------------------------------------ ##
     ## Developpers should never work with src = build.  ##
     ## ------------------------------------------------ ##

subpackage: DIR-NAME
  Declare a subpackage (i.e., AC_CONFIG_SUBDIRS) that needs to be
  bootstrapped too.
  E.g., \`subpackage: lock-system'.

Options:
  -h, --help                    display this message and exit
      --install-libtool WHERE   if needed, install the latest libtool
                                in the directory WHERE (e.g., \`build-aux')
  -n, --dry-run                 do nothing
      --no-recursive            do not bootstrap subpackages
EOF
  exit 0
}

getopt ()
{
    while test $# -ne 0
    do
        # Split options with an argument.
        case $1 in
          (*=*)
            local opt
            opt=$(echo "$1" | sed -e 's/=.*//')
            local arg
            arg=$(echo "$1" | sed -e 's/^[^=]*=//')
            shift
            set x "$opt" "$arg" "$@"
            shift
        esac

        case $1 in
            (-n|--dry-run) run=false;;
            (-h|--help) usage;;
            (--no-recursive)  recurse=false;;
            (--install-libtool) install_libtool=$2; shift;;
            (*) error 64 "invalid argument: $1";;
        esac
        shift
    done
}

stderr ()
{
  local i
  local me=$(basename "$0")
  for i
  do
    echo >&2 "$me: $i"
  done
}

error ()
{
  local exit=$1
  shift
  stderr "$@"
  exit $exit
}

run ()
{
  stderr "running: $*"
  if $run; then
    "$@"
  fi
}

fatal ()
{
  stderr "$red" "$@" "$std"
  # Be sure to die, even in subshell.  Exit is not strong enough.
  kill $pid
}

awk_strverscmp='
  # Use only awk features that work with 7th edition Unix awk (1978).
  # My, what an old awk you have, Mr. Solaris!
  END {
    while (length(v1) || length(v2)) {
      # Set d1 to be the next thing to compare from v1, and likewise for d2.
      # Normally this is a single character, but if v1 and v2 contain digits,
      # compare them as integers and fractions as strverscmp does.
      if (v1 ~ /^[0-9]/ && v2 ~ /^[0-9]/) {
	# Split v1 and v2 into their leading digit string components d1 and d2,
	# and advance v1 and v2 past the leading digit strings.
	for (len1 = 1; substr(v1, len1 + 1) ~ /^[0-9]/; len1++) continue
	for (len2 = 1; substr(v2, len2 + 1) ~ /^[0-9]/; len2++) continue
	d1 = substr(v1, 1, len1); v1 = substr(v1, len1 + 1)
	d2 = substr(v2, 1, len2); v2 = substr(v2, len2 + 1)
	if (d1 ~ /^0/) {
	  if (d2 ~ /^0/) {
	    # Compare two fractions.
	    while (d1 ~ /^0/ && d2 ~ /^0/) {
	      d1 = substr(d1, 2); len1--
	      d2 = substr(d2, 2); len2--
	    }
	    if (len1 != len2 && ! (len1 && len2 && substr(d1, 1, 1) == substr(d2, 1, 1))) {
	      # The two components differ in length, and the common prefix
	      # contains only leading zeros.  Consider the longer to be less.
	      d1 = -len1
	      d2 = -len2
	    } else {
	      # Otherwise, compare as strings.
	      d1 = "x" d1
	      d2 = "x" d2
	    }
	  } else {
	    # A fraction is less than an integer.
	    exit 1
	  }
	} else {
	  if (d2 ~ /^0/) {
	    # An integer is greater than a fraction.
	    exit 2
	  } else {
	    # Compare two integers.
	    d1 += 0
	    d2 += 0
	  }
	}
      } else {
	# The normal case, without worrying about digits.
	if (v1 == "") d1 = v1; else { d1 = substr(v1, 1, 1); v1 = substr(v1,2) }
	if (v2 == "") d2 = v2; else { d2 = substr(v2, 1, 1); v2 = substr(v2,2) }
      }
      if (d1 < d2) exit 1
      if (d1 > d2) exit 2
    }
  }
'

version_compare ()
{
  (
    # Locally ignore failures, otherwise we'll exit whenever $1 and $2
    # are not equal!
    set +e

    awk "$awk_strverscmp" v1="$1" v2="$2" /dev/null
    case $? in
      1)  echo '<';;
      0)  echo '=';;
      2)  echo '>';;
    esac
  )
}

# require TOOL REQUIREMENT [ERROR]
# --------------------------------
# Test that TOOL exists, and its version is at least REQUIREMENT.
# Check whether the environment contains a variable named like TOOL,
# but upper-cased, and use it instead of TOOL if so. If ERROR is
# present, use it instead of "error" to report it.
require ()
{
  local envvar_name
  envvar_name=$(echo $1 | tr '[:lower:]' '[:upper:]')
  local tool
  tool=$(printenv $envvar_name || echo $1)
  local version=$($tool --version | \
    sed -n 's/.*[^0-9.]\([0-9][0-9.]*\).*/\1/p;' | head -n1)
  local error="${3:-error}"

  test x"$version" != x ||
    $error 1 "$tool is required"

  local path
  path=$(which $tool)
  stderr "found $tool $version at $path"
  case $(version_compare "$2" "$version") in
   ( '>') $error 1 "$1 $2 or better is required: this is $tool $version";;
  esac
}


# install_libtool WHERE
# ---------------------
# Install libtool in the directory WHERE.
install_libtool ()
{
  local where
  where=$(cd "$1" && pwd)
  local dir=libtool-2.2.6
  local tarball=${dir}a.tar.gz
  local url=http://ftp.gnu.org/gnu/libtool/$tarball
  local here=$(pwd)

  mkdir -p "$where"
  cd "$where"

  # Get the source tree.
  test -f $tarball ||
    wget "$url"
  rm -rf "$dir"
  if tar zxf $tarball; then
    # Probably a broken tarball, fetch it again.
    rm -f $tarball
    wget "$url"
    tar zxf $tarball
  fi

  # Build.
  cd $dir
  mkdir _build
  cd _build
  ../configure --prefix=$where
  make
  make install
  cd "$here"
}


# Return the set of attributes corresponding to TAG in .externals.
attributes ()
{
  local f
  for f in $HOME/.libport/bootstrap.cfg externals/bootstrap.cfg .externals
  do
    if test -f "$f"; then
      perl -ne "s/^$1:\\s*// && print" "$f"
    fi
  done
}


# link_symbolic FROM TO
# ---------------------
# Install a link FROM that goes to TO.
link_symbolic ()
{
  local from=$1
  local to=$2
  # If we have an empty directory, we may have had a submodule
  # here in the past, so remove it. It is empty, so nothing
  # will be lost anyway.
  if test -d $from -a ! -L $from; then
    stderr "Attempting to remove pre-existing $from directory"
    rmdir $from 2> /dev/null || true
    if test -d $from; then
      fatal "$from is a non-empty directory. " \
	    "Please remove and restart."
    fi
  fi
  # Under cygwin, we will end up doing a copy anyway, so do not
  # even pretend to try to create a link.
  case $(uname) in
      (*CYGWIN*)
	  return 1;;
  esac
  local morf=$(dirname $(echo "$from" | sed 's,[^\\/]*,..,g'))

  # It is a nightmare to have incorrect links, diagnose this.
  if test -e $from; then
    if test ! -L $from; then
      fatal "$from exists and is not a symlink." \
            "Please remove and restart."
    fi
    current_to=$(readlink $from)
    if test "$current_to" != "$morf/$to"; then
      fatal "$from is a symlink to $current_to instead of $morf/$to." \
            "Please remove and restart."
    fi
  else
    # All is good, install the symlink.
    run ln -sf $morf/$to $from
  fi
}


# link_hard FROM TO
# -----------------
# We no longer use hard links, since this is invalid for directories.
# This is dead code.
link_hard ()
{
  case $(uname) in
     (*CYGWIN*)
	  return 1;;
  esac
  run ln "$2" "$1"
}


# link_copy FROM TO
# -----------------
link_copy ()
{
  stderr \
  "## ------------------------------------------------------------- ##" \
  "## Warning: Using cp instead of links is troublesome for         ##" \
  "## developpers.  This mode should be used by the buildfarm only, ##" \
  "## or on Windows.  See boostrap --help.                          ##" \
  "## ------------------------------------------------------------- ##"
  if test -e "$2"; then
    stderr "${red}Not copying $2 on $1: $1 exists."
  else
    run cp -pr "$2" "$1"
  fi
}


# link FROM TO
# ------------
# Install a link FROM that provides the contents of TO.
link ()
{
  local from=$1
  local to=$2

  stderr "Installing $from -> $to"
  mkdir -p $(dirname "$from")
  local kind
  for kind in $link_types
  do
      case $kind in
	  (symbolic|copy)
	      if link_$kind "$from" "$to"; then
		  return 0
	      fi
	      ;;
	  (*)
	      fatal "invalid link type: $kind"
	      ;;
      esac
  done
  stderr "failed to install link $1 -> $2"
  exit 1
}

set -e

install_libtool=build-aux
recurse=true
run=true

getopt "$@"

# If there are links to install, do it here.
#
# We used to always create symbolic links, which work fine with "src
# != build" builds, but some people (such as the build farm) insist on
# compiling in place.  As a result, "sdk" for instance is a symlink,
# and when "make" enters into "sdk", every occurrence of ".."
# (top_srcdir) points to a random place (well, it points to the parent
# of the pointee (libport/sdk/..), instead of the parent of the
# pointee (../sdk)).
#
# Of course we don't want to just copy, since then a check-in in
# "build-aux" for instance would no longer work.
#
# Note that not using symlinks, we can no longer "cd build-aux && git
# commit", since precisely what made this work is that git could find
# the build-aux's repository by walking the hierarchy up:
# build-aux/.. is actually libport, where git can find its files.
#
# Since there is no universally good solution, we read
# "~/.libport/bootstrap.cfg" to know what kind of link must be
# installed here.
#
# IMHO people *and* the buildfarm should be using src != build.
link_types=$(attributes links | tr -cs 'a-z' ' ')
if test -z "$link_types"; then
  link_types="symbolic"
fi
attributes '(hard)?link' |
while read link
do
  # "from -> to" in the sense of symlinks: ./$from points to ./$to.
  from=$(echo "$link" | perl -pe 's/\s*->.*$//')
  to=$(echo "$link"   | perl -pe 's/^.*->\s*//')

  link "$from" "$to"
done

if test -f .externals; then
  fatal "Remove \`.externals', use \`bootstrap.cfg' instead."
fi

keep=$(attributes keep)
for i in $keep
do
  run cp -f $i $i.bak
done

# Requirements over bootstrap tools.
require autoconf $autoconf_prereq
require automake $automake_prereq

# On some environments (Darwin Ports), libtoolize is glibtoolize.
# I suppose their autoreconf is adjusted accordingly, but I use
# my custom Autoconf...
libtoolize=libtoolize
for l in $(cd $install_libtool && pwd)/bin/libtoolize "$LIBTOOLIZE" glibtoolize libtoolize;
do
  if ($l --version) >/dev/null 2>&1; then
    libtoolize=$l
    break
  fi
done
export LIBTOOLIZE=$libtoolize
# Two passes, in the second we use our libtool.
for pass in 1 2
do
  case $pass in
    (1) if require $libtoolize $libtool_prereq false; then
          break
        else
          install_libtool "$install_libtool"
          export LIBTOOLIZE=libtoolize
        fi;;
    (2) require $libtoolize $libtool_prereq;;
  esac
done

# Recursive bootstrapping.
if $recurse; then
  # Avoid sub shells, as they hide set -e sub failures.
  pwd=$(pwd)
  for i in $(attributes "subpackage")
  do
    # The format for this message is not free: taken from Emacs, itself
    # using GNU Make's format.
    stderr "Entering directory \`$i'";
    cd "$i"
    ./bootstrap
    stderr "Leaving directory \`$i'";
    cd "$pwd"
  done
fi

run autoreconf --no-recursive --force --verbose --install

for i in $keep
do
  run mv -f $i.bak $i
done

# If the pseudo-standard name "_build" is used, then how about trying
# to continue the re-build?
if test -f _build/config.status; then
  run cd _build
  run ./config.status --recheck
  run ./config.status
  run make
fi

# Local Variables:
# mode: shell-script
# End:
