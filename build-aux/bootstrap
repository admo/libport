#! /bin/sh

##
## bootstrap: This file is part of build-aux.
## Copyright (C) Gostai S.A.S., 2006-2008.
##
## This software is provided "as is" without warranty of any kind,
## either expressed or implied, including but not limited to the
## implied warranties of fitness for a particular purpose.
##
## See the LICENSE file for more information.
## For comments, bug reports and feedback: http://www.urbiforge.com
##

usage ()
{
  cat <<EOF
Usage: $0 [OPTIONS]

Bootstrap the GNU Build system using autoreconf.

This file and git-my-update use a common file, \`.externals', to
describe what's to be done.  Its syntax is dummy and made to be
easily sed-parsable.  It supports the following directives (which
must be in column 0, anything else is silently ignored):

external: [DIR-NAME ->] REPO-NAME
  Install REPO-NAME as submodule, and update it when needed.
  E.g. \`external: libport'.
       \`external: tests -> urbivalid'.

link: FROM -> TO
  Install a symlink named FROM that points to TO.
  E.g. \`link include/libport -> libport/include/libport'.

hardlink: FROM -> TO
  Install an hardlink named FROM that points to TO.
  E.g. \`hardlink sdk -> libport/sdk'.

subpackage: DIR-NAME
  Declare a subpackage (i.e., AC_CONFIG_SUBDIRS) that needs to be
  bootstrapped too.
  E.g., \`subpackage: lock-system'.

Options:
  -h, --help          display this message and exit
  -n, --dry-run       do nothing
      --no-recursive  do not bootstrap subpackages
EOF
}

stderr ()
{
  local i
  local me=$(basename "$0")
  for i
  do
    echo >&2 "$me: $i"
  done
}

run ()
{
  stderr "running: $*"
  if $run; then
    "$@"
  fi
}

fatal ()
{
  echo >&2 "$0: $@"
  exit 1
}

awk_strverscmp='
  # Use only awk features that work with 7th edition Unix awk (1978).
  # My, what an old awk you have, Mr. Solaris!
  END {
    while (length(v1) || length(v2)) {
      # Set d1 to be the next thing to compare from v1, and likewise for d2.
      # Normally this is a single character, but if v1 and v2 contain digits,
      # compare them as integers and fractions as strverscmp does.
      if (v1 ~ /^[0-9]/ && v2 ~ /^[0-9]/) {
	# Split v1 and v2 into their leading digit string components d1 and d2,
	# and advance v1 and v2 past the leading digit strings.
	for (len1 = 1; substr(v1, len1 + 1) ~ /^[0-9]/; len1++) continue
	for (len2 = 1; substr(v2, len2 + 1) ~ /^[0-9]/; len2++) continue
	d1 = substr(v1, 1, len1); v1 = substr(v1, len1 + 1)
	d2 = substr(v2, 1, len2); v2 = substr(v2, len2 + 1)
	if (d1 ~ /^0/) {
	  if (d2 ~ /^0/) {
	    # Compare two fractions.
	    while (d1 ~ /^0/ && d2 ~ /^0/) {
	      d1 = substr(d1, 2); len1--
	      d2 = substr(d2, 2); len2--
	    }
	    if (len1 != len2 && ! (len1 && len2 && substr(d1, 1, 1) == substr(d2, 1, 1))) {
	      # The two components differ in length, and the common prefix
	      # contains only leading zeros.  Consider the longer to be less.
	      d1 = -len1
	      d2 = -len2
	    } else {
	      # Otherwise, compare as strings.
	      d1 = "x" d1
	      d2 = "x" d2
	    }
	  } else {
	    # A fraction is less than an integer.
	    exit 1
	  }
	} else {
	  if (d2 ~ /^0/) {
	    # An integer is greater than a fraction.
	    exit 2
	  } else {
	    # Compare two integers.
	    d1 += 0
	    d2 += 0
	  }
	}
      } else {
	# The normal case, without worrying about digits.
	if (v1 == "") d1 = v1; else { d1 = substr(v1, 1, 1); v1 = substr(v1,2) }
	if (v2 == "") d2 = v2; else { d2 = substr(v2, 1, 1); v2 = substr(v2,2) }
      }
      if (d1 < d2) exit 1
      if (d1 > d2) exit 2
    }
  }
'

version_compare ()
{
  (
    # Locally ignore failures, otherwise we'll exit whenever $1 and $2
    # are not equal!
    set +e

    awk "$awk_strverscmp" v1="$1" v2="$2" /dev/null
    case $? in
      1)  echo '<';;
      0)  echo '=';;
      2)  echo '>';;
    esac
  )
}

# require TOOL REQUIREMENT
# ------------------------
# Test that TOOL exists, and its version is at least REQUIREMENT.
# Check whether the environment contains a variable named like TOOL,
# but upper-cased, and use it instead of TOOL if so.
require ()
{
  envvar_name=$(echo $1 | tr '[:lower:]' '[:upper:]')
  tool=$(printenv $envvar_name || echo $1)
  local version=$($tool --version | \
    sed -n 's/.*[^0-9.]\([0-9][0-9.]*\).*/\1/p;q')
  test x"$version" != x ||
    fatal "$tool is required"
  case $(version_compare "$2" "$version") in
    '>') fatal "$1 $2 or better is required: this is $tool $version";;
  esac
}


# Return the set of attributes corresponding to TAG in .externals.
attributes ()
{
  if test -f .externals; then
    perl -ne "s/^$1:\\s*// && print" .externals
  fi
}

set -e

recurse=true
run=true

for arg
do
  case $arg in
    -n|--dry-run) run=false;;
    -h|--help) usage;;
    --no-recursive)  recurse=false;;
    *) stderr "invalid argument: $arg"
       exit 64;;
  esac
done

# If there are symlinks to install, do it here.
attributes link |
while read link
do
  # "from -> to" in the sense of symlinks: ./$from points to ./$to.
  from=$(echo "$link" | perl -pe 's/\s*->.*$//')
  to=$(echo "$link"   | perl -pe 's/^.*->\s*//')

  if ! test -e $from; then
    stderr "Installing $from -> $to"
    mkdir -p $(dirname "$from")
    morf=$(dirname $(echo "$from" | sed 's,[^\\/]*,..,g'))
    run ln -sf $morf/$to $from ||
    run ln $to $from ||
    run cp -pr $to $from
  fi
done

# If there are hardlinks to install, do it here.
attributes hardlink |
while read link
do
  # "from -> to" in the sense of symlinks: ./$from points to ./$to.
  from=$(echo "$link" | perl -pe 's/\s*->.*$//')
  to=$(echo "$link"   | perl -pe 's/^.*->\s*//')

  if ! test -e $from; then
    stderr "Installing $from -> $to"
    mkdir -p $(dirname "$from")
    morf=$(dirname $(echo "$from" | sed 's,[^\\/]*,..,g'))
    run ln $to $from ||
    run cp -pr $to $from
  fi
done

if test -f bootstrap.cfg; then
  source bootstrap.cfg
fi

for i in $keep
do
  run cp $i $i.bak
done

# Requirements over bootstrap tools.
require autoconf 2.61
require automake 1.10
# On some environments (Darwin Ports), libtoolize is glibtoolize.
# I suppose their autoreconf is adjusted accordingly, but I use
# my custom Autoconf...
libtoolize=libtoolize
for l in "$LIBTOOLIZE" glibtoolize libtoolize;
do
  if ($l --version) >/dev/null 2>&1; then
    libtoolize=$l
    break
  fi
done
export LIBTOOLIZE=$libtoolize
require $libtoolize 1.5.22

if $recurse; then
  # Recursive bootstrapping.
  for i in $(attributes "subpackage")
  do
    (
      # The format for this message is not free: taken from Emacs, itself
      # using GNU Make's format.
      stderr "Entering directory \`$i'";
      cd $i
      ./bootstrap
      stderr "Leaving directory \`$i'";
    )
  done
fi

run autoreconf --no-recursive --force --verbose --install

# FIXME: autoheader does not obey --force.
run touch $(find . -name 'config.h.in')

for i in $keep
do
  run mv $i.bak $i
done

# If the pseudo-standard name "_build" is used, then how about trying
# to continue the re-build?
if test -f _build/config.status; then
  run cd _build
  run ./config.status --recheck
  run ./config.status
  run make
fi

# Local Variables:
# mode: shell-script
# End:
