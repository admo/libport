#! /bin/sh

set -e

# This script is inspired from the GNU Lib's script "git-version-gen".
# But we are not GPL, so we have to reimplement it.  More
# documentation is available there.  See also "package-version.txt".

me=$(basename "$0")
medir=$(dirname "$0")
: ${TMPDIR=/tmp}
tmp=$TMPDIR/$me.$$

trap 'exit' 1 2 13 15
trap 'res=$?; rm -f "$tmp" 2>/dev/null; exit $res' 0

stderr ()
{
  local i
  for i
  do
    echo >&2 "$me: $i"
  done
}

fatal ()
{
  stderr "$@"
  exit 1
}

usage ()
{
  cat <<EOF
Usage: $0 [OPTIONS...]

Options:
  -h, --help         display this message and exit
  -n, --no-eol       do not output the trailing newline
  -o, --output=FILE  file to create
                     defaults to stdout
  -s, --srcdir=DIR   location of the top srcdir
                     used to locate the Git repository if in use

Output formats:
  -f, --file     output a string suitable as a file name
                 (convert slashes to dashes)
  -r, --raw      output the raw result [default]
  -H, --header   output as a header file suitable for C/C++

See build-aux/package-version.txt for more information.
EOF
  exit 0
}

getopt ()
{
  while test $# -ne 0; do
    case $1 in
	--*=*)
	    opt=$(echo "$1" | sed -e 's/=.*//')
	    val=$(echo "$1" | sed -e 's/[^=]*=//')
	    shift
	    set dummy "$opt" "$val" ${1+"$@"};
	    shift
	    ;;
    esac

    case $1 in
      (-h | --help)   usage;;
      (-H | --header) format=header;;
      (-f | --file)   format=file;;
      (-n | --no-eol) # m4_esyscmd does not strip the ending \n.
                      prune_eol="tr -d '\012'";;
      (-r | --raw)    format=raw;;
      (-o | --output) output=$2; shift;;
      (-s | --srcdir) srcdir=$2; shift;;
      (*)  fatal "unexpected argument: $1";;
    esac
    shift
  done
}

## ------ ##
## Main.  ##
## ------ ##

# A command to kill the eol.
prune_eol=cat
# Output format
format=raw
srcdir=.
output=

getopt "$@"

# Are we in a git repository?  If we are, there should be files here.
if (cd $srcdir && git ls-files | grep .) >/dev/null 2>&1; then
  # In a repo.  Compute the most up to date answer.
  res=$(cd $srcdir && git describe)
else
  # Not in a repo.  We *need* .version to exist.
  res=$(cat $srcdir/.version)
fi

# Should not happen.
test -n "$res" ||
  res=UNKNOWN

case $format in
  (raw)
     echo "$res" | $prune_eol;;
  (file)
     echo "$res" | sed 's,/,-,g' | $prune_eol;;
  (header)
    cat <<EOF
#ifndef GIT_VERSION_HH
# define GIT_VERSION_HH

# define GIT_VERSION "$res"

#endif
EOF
    ;;
esac >$tmp

case $output in
  ('')
    cat $tmp
    ;;
  (*)
    $medir/move-if-change $tmp $output
    ;;
esac
