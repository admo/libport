#! /usr/bin/perl -w

use strict;
use IO::File;

# TODO.
#
# This file has gone through many different approaches, and there are
# remains that need to be cleaned.
#
# 1. Clearly have two run modes: one to create/update .version from
# git, if possible.  Should be lazy: don't update if no changes.
#
# 2. One that creates the output files, only from .version, and not
# even trying to run git.  Don't be lazy, always override, to avoid
# having to deal with time stamp files.  It is simple to use make to
# update output files from .version, which is lazy.

=head1 NAME

=head1 SYNOPSIS

  git-version-gen [OPTIONS...]

=head1 OPTIONS

General options:

=over 4

=item B<-d>, B<--directory>

Create the directory of the output file if needed.

=item B<-h>, B<--help>

display this message and exit.

=item B<-n>, B<--no-eol>

do not output the trailing newline.

=item B<-o>, B<--output>=I<file>

file to create.  Defaults to stdout.

=item B<-p>, B<--prefix>=I<id>

Prefix to use for the CPP guards.  For instance I<LIBPORT_>.  Defaults
to I<PACKAGE_>.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-s>, B<--srcdir>=I<dir>

location of the top srcdir.
Used to locate the Git repository if in use.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=back

Output Formats:

=over 4

=item B<-H>, B<--header>

output as a header file suitable for C/C++.

=item B<-f>, B<--file>

output a string suitable as a file name.
Converts slashes to dashes.

=item B<-r>, B<--raw>

output the raw result [default].

=item B<-u>, B<--urbi>

output as an Urbi file.

=back

See build-aux/package-version.txt for more information.

=cut


# The file that maintains a copy of the current version.
my $cache;

# Output format.
my $format = 'raw';

# Whether we make the directory first.
my $directory_p = 0;

# Whether we strip the trailing \n (to please m4_syscmd which does not
# strip it).
my $no_eol = 0;

my $output;

# CPP guard prefix.
my $prefix = 'PACKAGE_';

# Where the git repo is (if it exists).
my $srcdir = '.';

my $verbose = 1;

=head1 FUNCTIONS

=over 4

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  print STDERR "$0: ", @message
    if $level <= $verbose;
}


sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Generate and cache git describe data",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}


=item C<ensure_parent_dir($filename)>

If I<$directory_p>, create, it needed, the directory that will contain
I<$filename>.

=cut

sub ensure_parent_dir ($)
{
  my ($file) = @_;
  if ($directory_p)
    {
      use File::Basename;
      my $dir = dirname $file;
      if (! -d $dir)
        {
          use File::Path;
          mkpath ($dir, { verbose => $verbose, })
            or die "cannot create $dir: $!";
        }
    }
}

######################################################################

sub getopt ()
{
  use Getopt::Long;
  my %option = (
    "c|cache=s"     => \$cache,
    "d|directory"   => sub { $directory_p = 1 },
    "f|file"        => sub { $format = 'file' },
    "l|latex"       => sub { $format = 'latex' },
    "H|header"      => sub { $format = 'header' },
    "h|help"        => sub { help ($verbose) },
    "n|no-eol"      => sub { $no_eol = 1 },
    "o|output=s"    => \$output,
    "p|prefix=s"    => \$prefix,
    "q|quiet"       => sub { --$verbose },
    "r|raw"         => sub { $format = 'raw' },
    "s|srcdir=s"    => \$srcdir,
    "u|urbi"        => sub { $format = 'urbi' },
    "v|verbose"     => sub { ++$verbose },
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;
}

######################################################################

sub git
{
  my $res = `git --git-dir=$srcdir/.git @_`
    or die "cannot run git";
  chomp $res;
  return $res;
}

sub save ($$)
{
  my ($file, $contents) = @_;
  if (! -f $file || `cat $file` ne $contents)
    {
      verbose 1, "Updating $file\n";
      ensure_parent_dir $file;
      my $out = new IO::File ">$file" or die;
      print $out $contents;
    }
  else
    {
      verbose 1, "$file is unchanged\n";
    }
}

######################################################################

sub fetch_keywords ()
{
  # Date -> $date and so forth.
  my %res;
  # Are we in a git repository?
  if (-d "$srcdir/.git")
    {
      verbose 2, "in a git repository\n";

      # Date, Rev, and Id.
      my $log = git 'log', '-1',
      '--pretty="format:Date: %ai%nId: %h (%ai %ae: %s)%nRev: %h%n"';

      # Description, Version, TarballVersion.
      $log =~ s{^(\w+):\s*(.*)$}{ $res{$1} = $2; ''; }emg;
      $res{Description} = git 'describe';
      ($res{Version} = $res{Description}) =~ s/-[^-]*$//;
      ($res{TarballVersion} = $res{Description}) =~ s,/,-,g;

      # Cache the result, only if needed.
      my $cached = '';
      for my $k (sort keys %res)
        {
          $cached .= "$k: $res{$k}\n";
        }
      save $cache, $cached;
    }
  else
    {
      verbose 2, "not in a git repository: no $srcdir/.git\n";
      my $in = new IO::File $cache or die "cannot open $cache: $!";
      while ($_ = $in->getline)
        {
          s{(\w+):\s*(.*)}{ $res{$1} = $2; ''; }e;
        }
    }
  if (3 <= $verbose)
    {
      for my $k (sort keys %res)
        {
          print STDERR "$0: $k: $res{$k}\n";
        }
    }
  return %res;
}

=item C<escape(\%hashref)>

Escape the values of C<%hashref> for C string syntax.

=cut

sub escape(\%)
{
  my ($hash) = @_;
  for (values %$hash)
    {
      s/[\\\"]/\\$&/g;
    }
}

=item C<generate_file(%keyword)>

Return as file name.

=cut

sub generate_file(%)
{
  my $res = generate_raw(@_);
  $res =~ s,/,-,g;
  return $res;
}

=item C<generate_header(%keyword)>

Generate a C/C++ header.

=cut

sub generate_header(%)
{
  my (%keyword) = @_;
  my $guard = uc $output;
  $guard =~ s/\W/_/g;
  escape %keyword;
  return <<EOF;
#ifndef $guard
# define $guard

// The SCM version string.
// Overrides that from config.h.
# ifdef ${prefix}VERSION
#  undef ${prefix}VERSION
# endif
# define ${prefix}VERSION "$keyword{Version}"

// The SCM revision string.
# define ${prefix}REVISION "$keyword{Rev}"

// The SCM identification string.
# define ${prefix}ID \\
  "$keyword{Id}"

// The SCM date string.
# define ${prefix}DATE "$keyword{Date}"

// Version and revision together.
# define ${prefix}VERSION_REV \\
  "version " ${prefix}VERSION " rev. " ${prefix}REVISION

#endif // !$guard
EOF
}

=item C<generate_raw(%keyword)>

Return the raw output from git-describe.

=cut

sub generate_raw(%)
{
  my (%keyword) = @_;
  my $res = $keyword{Rev};
  $res .= "\n"
    unless $no_eol;
  return $res;
}

=item C<generate_latex(%keyword)>

Generate a LaTeX file.

=cut

sub generate_latex(%)
{
  my (%keyword) = @_;
  return <<EOF;
% The SCM version string.
\\newcommand{\\VcsVersion}{$keyword{Version}\\xspace}

% The SCM revision string.
\\newcommand{\\VcsRevision}{$keyword{Rev}\\xspace}

% The SCM identification string.
\\newcommand{\\VcsId}{$keyword{Id}\\xspace}

% The SCM date string.
\\newcommand{\\VcsDate}{$keyword{Date}\\xspace}

% Version and revision together.
\\newcommand{\\VcsVersionRev}{%
  version \\VcsVersion rev. \\VcsRevision%
}
EOF
}

=item C<generate_urbi(%keyword)>

Generate an Urbi file.

=cut

sub generate_urbi(%)
{
  my (%keyword) = @_;
  escape %keyword;
  return <<EOF;
class System.PackageInfo
{
  // The SCM version string.
  var version = "$keyword{Version}";

  // The SCM revision string.
  var revision = "$keyword{Rev}";

  // The SCM identification string.
  var id = "$keyword{Id}";

  // The SCM date string.
  var date = "$keyword{Date}";

  // Version and revision together.
  function version_rev
  {
    "version " + version + " rev. " + revision
  };
};
EOF
}

=item C<generate($format, %keyword)>

Generate the result for C<$format>.

=cut

sub generate($%)
{
  my ($format, %keyword) = @_;
  my %converter =
    (
     file   => \&generate_file,
     latex  => \&generate_latex,
     header => \&generate_header,
     raw    => \&generate_raw,
     urbi   => \&generate_urbi,
    );
  return &{$converter{$format}}(%keyword);
}

######################################################################

## ------ ##
## Main.  ##
## ------ ##

getopt;
$cache = "$srcdir/.version"
  unless $cache;

# Looks for the SCM keywords.
my %keyword = fetch_keywords;

# Compute the main result.
my $res = generate($format, %keyword);

# Save the result.
if ($res)
{
  if ($output)
    {
      save $output, $res;
    }
  else
    {
      print $res;
    }
}

### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
