#! /usr/bin/perl -w

use strict;
use English;

=head1 NAME

instrument - automatic binary instrumentation

=head1 SYNOPSIS

  instrument [OPTIONS...] [--] PROGRAM [ARGUMENTS...]

Instrument the PROGRAM when possible.

=head1 OPTIONS

The environment variable INSTRUMENTFLAGS is prepended to the command
line arguments before option parsing.

General options:

=over 4

=item B<-f>, B<--force>

By default no instrumentation is done on shell scripts.  It is
frequent when running tests in the build tree to actually test shell
scripts that bounce to actual binaries. With this option,
instrumentation is always performed.

=item B<-h>, B<--help>

Display this message and exit.

=item B<--libtool>=I<libtool>.

Specify what Libtool to use.  By default uses the first one of
I<$LIBTOOL>, I<glibtool>, I<libtool> whose first line of --version
contains I<GNU libtool>.

=item B<-m>, B<--mode>=I<mode>.

Specify the instrumentation mode:

=over 4

=item I<auto>

Chose the most appropriate mode.  Default.

=item I<none>

No instrumentation.

=item I<osx>

Use Mac OS X special malloc related environment variables.

=item I<valgrind>

Use valgrind (memcheck).

=back

=item B<-n>, B<--dry-run>

Don't actually run any command; just print them.

=item B<-o>, B<--output>=I<file>

Save the logs in I<file> instead of standard error.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=item B<-V>, B<--valgrind-option>=I<option>

Pass I<option> to Valgrind.  Accumulates.  For instance B<-V
--suppressions=I<suppression-file>>.

=back

=cut

# Whether not to run the command, but just display it.
my $dry_run = 0;

# Whether scripts should also be instrumented.
my $force = 0;

# The libtool the use.  If undef, use find_gnu_libtool to find it.
my $libtool;

# Instrument mode.
use constant
{
  mode_auto       => 1,
  mode_none       => 2,
  mode_osx        => 3,
  mode_valgrind   => 4,
};
my $mode = mode_auto;
# From value to name.
my %mode_name =
  (
   mode_auto()     => "auto",
   mode_none()     => "none",
   mode_osx()      => "osx",
   mode_valgrind() => "valgrind",
  );
# From name to value.
my %mode = map { $mode_name{$_} => $_ } keys %mode_name;

# Where to save logs.  STDERR if undef.
my $output;

# Depending on the version of Valgrind, use --log-file or
# --log-file-exactly.
my $valgrind_log_file = '--log-file';

# More options for valgrind.
my @valgrind_option =
  (
   '--error-exitcode=242',
   '--gen-suppressions=all',
   # Some configuration might be needed here if Valgrind on Linux does
   # not support this OS X option.
   '--auto-run-dsymutil=yes',
  );

# Verbosity level.
my $verbose = 1;

=head1 FUNCTIONS

=over 4

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  print STDERR "$0: ", @message
    if $level <= $verbose;
}


sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Portable instrumentation",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

######################################################################

sub getopt ()
{
  use Getopt::Long;

  my $envvar = 'INSTRUMENTFLAGS';
  unshift @ARGV, split(/ /, $ENV{$envvar})
    if exists $ENV{$envvar};

  my %option = (
    "f|force"       => \$force,
    "h|help"        => sub { help ($verbose) },
    "libtool=s"
      => sub
         {
           if (-x $_[1])
             {
               $libtool = $_[1];
             }
           else
             {
               verbose 0, "--libtool ignored: not an executable: $_[1]\n";
             }
         },
    "m|mode=s"      => sub { exists $mode{$_[1]} or die "unknown mode: $_[1]";
                             $mode = $mode{$_[1]}; },
    "n|dry-run"     => \$dry_run,
    "o|output=s"    => \$output,
    "q|quiet"       => sub { --$verbose },
    "v|verbose+"    => \$verbose,
    "V|valgrind-option=s" => \@valgrind_option,
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;

  # Can't be verbose before processing --force...
  verbose 2, "prepended arguments $envvar=$ENV{$envvar}\n"
    if exists $ENV{$envvar};

  # If there is one, do not keep the --.
  shift @ARGV
    if exists $ARGV[0] && $ARGV[0] eq '--';
}

######################################################################

# If $mode is auto, find the appropriate mode.
sub compute_mode ()
{
  my $valgrind_help = `valgrind --help 2>/dev/null`;

  if ($valgrind_help)
    {
      $mode = mode_valgrind;
      $valgrind_log_file = '--log-file-exactly'
        if $valgrind_help =~ /--log-file-exactly/;
    }
  elsif ($OSNAME eq 'darwin')
    {
      $mode = mode_osx;
    }
}

######################################################################

sub file_type ($)
{
  my ($file) = @_;
  my $res = `file $file`;
  chop $res;
  $res =~ s/^\Q$file\E:\s*//;
  if ($res =~ /shell script/)
    {
      # The sed|grep pattern comes from libtool itself.
      system("sed -e 4q \"$file\" 2>/dev/null |
              grep -c '^# Generated by .*libtool' > /dev/null 2>&1");
      $res = 'libtool wrapper'
        if $? == 0;
    }
  verbose 2, "type of $file: $res\n";
  return $res;
}


######################################################################

sub instrument_prefix ($)
{
  my ($mode) = @_;
  my @res = ();
  if ($mode == mode_osx)
    {
      @res = (
        "env",
        "MallocBadFreeAbort=1",
        "MallocCheckHeapAbort=1",
        "MallocErrorAbort=1",
        "MallocGuardEdges=1",
        "MallocPreScribble=1",
        "MallocScribble=1",
        );
      push @res, "MallocLogFile=$output"
        if $output;
    }
  elsif ($mode == mode_valgrind)
    {
      @res = ("valgrind", @valgrind_option);
      push @res, "--quiet"
        if 0 == $verbose;
      push @res, "--verbose"
        if 2 <= $verbose;
      push @res, "$valgrind_log_file=$output"
        if $output;
      push @res, "--";
    }
  return @res;
}

=item C<find_gnu_libtool()>

If C<$libtool> is defined, use that one, otherwise set try to find GNU
Libtool and return it, otherwise return undef.

=cut

sub find_gnu_libtool ()
{
  # List of libtools to use.
  my @libtool;
  # If the user specified the libtool to use, use that one.
  if ($libtool)
    {
      @libtool = ($libtool);
    }
  else
    {
      # Beware that on Mac OS X, libtool is not GNU libtool.
      @libtool = qw(glibtool libtool);
      unshift @libtool, $ENV{LIBTOOL}
        if exists $ENV{LIBTOOL};
    }
  for my $libtool (@libtool)
    {
      my $version = `$libtool --version 2>/dev/null |
                       sed 1q |
                       grep 'GNU libtool'`;
      if ($? == 0)
        {
          chomp $version;
          verbose 2, "using GNU Libtool: $libtool: $version\n";
          return $libtool;
        }
    }
  verbose 2, "did not find GNU Libtool as: @libtool\n";
}


# instrument_prefix($mode, @argv)
# -------------------------------
sub instrument ($@)
{
  my ($mode, @argv) = @_;
  my @res = @argv;

  # No instrumentation required.
  return @res
    if $mode == mode_none;

  # The type of the program to instrument.
  my $type = exists $argv[0] ? file_type $argv[0] : '';

  # Instrument if required, or if not a script.
  return @res
    unless $force || $type !~ /script/;

  # If it's a libtool wrapper, don't instrument it unless we can find
  # libtool.
  my $libtool = $type =~ /libtool wrapper/ ? find_gnu_libtool : undef;

  # Really instrument here.
  verbose 2, "mode: $mode: $mode_name{$mode}\n";
  unshift @res, instrument_prefix($mode);

  # Now, if this requires libtool, pass it.
  unshift @res, $libtool, "--mode=execute"
    if $libtool;

  return @res;
}

######################################################################

=item C<shellescape($str)>

Return C<$str> properly escaped for a regular Bourne shell.  Avoid
useless quotes to produce a readable result.

This is insufficient.  We actually need to have the result "eval"'ed.

=cut

sub shellescape($)
{
  my ($str) = @_;
  if ($str =~ m([^-=+_/.[:alnum:]]))
    {
      $str =~ s,[\\'],'\\$&',g;
      $str = "'$str'";
    }
  return $str;
}

## ------ ##
## Main.  ##
## ------ ##


# If we can see our "built-in" instrument.supp file, use it.
{
  my $supp = "$0.supp";
  push @valgrind_option, "--suppressions=$supp"
    if -f $supp;
}

getopt;

compute_mode
  if $mode == mode_auto;
my @res = instrument($mode, @ARGV);
@res = map { shellescape($_); } @res;
verbose 2, "result: @res\n";
if ($dry_run)
{
  print "@res\n";
}
else
{
  exec { $res[0] } @res
    or die "couldn't exec @res: $!\n";
}


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
