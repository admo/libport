#! /usr/bin/perl -w

use strict;
use English;

=head1 NAME

instrument - automatic binary instrumentation

=head1 SYNOPSIS

  instrument [OPTIONS...] [--] PROGRAM [ARGUMENTS...]

Instrument the PROGRAM when possible.

=head1 OPTIONS

The environment variable INSTRUMENTFLAGS is prepended to the command
line arguments before option parsing.

General options:

=over 4

=item B<-f>, B<--force>

By default no instrumentation is done on shell scripts.  It is
frequent when running tests in the build tree to actually test shell
scripts that bounce to actual binaries. With this option,
instrumentation is always performed.

=item B<-h>, B<--help>

Display this message and exit.

=item B<-m>, B<--mode>=I<mode>.

Specify the instrumentation mode:

=over 4

=item I<auto>

Chose the most appropriate mode.  Default.

=item I<none>

No instrumentation.

=item I<osx>

Use Mac OS X special malloc related environment variables.

=item I<valgrind>

Use valgrind (memcheck).

=back

=item B<-n>, B<--dry-run>

Don't actually run any command; just print them.

=item B<-o>, B<--output>=I<file>

Save the logs in I<file> instead of standard error.

=item B<-q>, B<--quiet>

Be less verbose.  Accumulates.

=item B<-v>, B<--verbose>

Be more verbose.  Accumulates.

=item B<-V>, B<--valgrind-option>=I<option>

Pass I<option> to Valgrind.  Accumulates.  For instance B<-V
--suppressions=I<suppression-file>>.

=back

=cut

# Whether scripts should also be instrumented.
my $force = 0;

# Instrument mode.
use constant
{
  mode_auto       => 1,
  mode_none       => 2,
  mode_osx        => 3,
  mode_valgrind   => 4,
};
my $mode = mode_auto;
# From value to name.
my %mode_name =
  (
   mode_auto()     => "auto",
   mode_none()     => "none",
   mode_osx()      => "osx",
   mode_valgrind() => "valgrind",
  );
# From name to value.
my %mode = map { $mode_name{$_} => $_ } keys %mode_name;

# Where to save logs.  STDERR if undef.
my $output;

# Depending on the version of Valgrind, use --log-file or
# --log-file-exactly.
my $valgrind_log_file = '--log-file';

# More options for valgrind.
my @valgrind_option =
  (
   "--error-exitcode=242",
  );

# Verbosity level.
my $verbose = 1;

=head1 FUNCTIONS

=over 4

=item C<verbose($level, @message)>

Report the C<@message> is C<$level> E<lt>= C<$verbose>.

=cut

sub verbose($@)
{
  my ($level, @message) = @_;
  print STDERR "$0: ", @message
    if $level <= $verbose;
}


sub help ($)
{
  my ($verbose) = @_;
  use Pod::Usage;
  # See <URL:http://perldoc.perl.org/pod2man.html#NOTES>.
  pod2usage( { -message => "Portable instrumentation",
               -exitval => 0,
               -verbose => $verbose,
               -output  => \*STDOUT });
}

######################################################################

sub getopt ()
{
  use Getopt::Long;

  my $envvar = 'INSTRUMENTFLAGS';
  unshift @ARGV, split(/ /, $ENV{$envvar})
    if exists $ENV{$envvar};

  my %option = (
    "f|force"       => \$force,
    "h|help"        => sub { help ($verbose) },
    "m|mode=s"      => sub { exists $mode{$_[1]} or die "unknown mode: $_[1]";
                             $mode = $mode{$_[1]}; },
    "o|output=s"    => \$output,
    "q|quiet"       => sub { --$verbose },
    "v|verbose+"    => \$verbose,
    "V|valgrind-option=s" => \@valgrind_option,
    );
  Getopt::Long::Configure ("bundling", "pass_through");
  GetOptions (%option)
    or exit 1;

  # Can't be verbose before processing --force...
  verbose 2, "prepended arguments $envvar=$ENV{$envvar}\n"
    if exists $ENV{$envvar};

  # If there is one, do not keep the --.
  shift @ARGV
    if exists $ARGV[0] && $ARGV[0] eq '--';
}

######################################################################

# If $mode is auto, find the appropriate mode.
sub compute_mode ()
{
  my $valgrind_help = `valgrind --help 2>/dev/null`;

  if ($valgrind_help)
    {
      $mode = mode_valgrind;
      $valgrind_log_file = '--log-file-exactly'
        if $valgrind_help =~ /--log-file-exactly/;
    }
  elsif ($OSNAME eq 'darwin')
    {
      $mode = mode_osx;
    }
}

######################################################################

sub file_type ($)
{
  my ($file) = @_;
  my $res = `file $file`;
  chop $res;
  if ($res =~ /shell script/)
    {
      # The sed|grep pattern comes from libtool itself.
      system("sed -e 4q \"$file\" 2>/dev/null |
              grep -c '^# Generated by .*libtool' > /dev/null 2>&1");
      $res = 'libtool wrapper'
        if $? == 0;
    }
  verbose 2, "type of $file: $res\n";
  return $res;
}


######################################################################

sub instrument_prefix ($)
{
  my ($mode) = @_;
  my @res = ();
  if ($mode == mode_osx)
    {
      @res = (
        "env",
        "MallocBadFreeAbort=1",
        "MallocCheckHeapAbort=1",
        "MallocErrorAbort=1",
        "MallocGuardEdges=1",
        "MallocPreScribble=1",
        "MallocScribble=1",
        );
      push @res, "MallocLogFile=$output"
        if $output;
    }
  elsif ($mode == mode_valgrind)
    {
      @res = ("valgrind", @valgrind_option);
      push @res, "--quiet"
        if 0 == $verbose;
      push @res, "--verbose"
        if 2 <= $verbose;
      push @res, "$valgrind_log_file=$output"
        if $output;
      push @res, "--";
    }
  return @res;
}

sub find_gnu_libtool ()
{
  # Beware that on Mac OS X, libtool is not GNU libtool.
  my @libtool = qw(glibtool libtool);
  unshift @libtool, $ENV{LIBTOOL}
    if exists $ENV{LIBTOOL};
  for my $libtool (@libtool)
    {
      my $version = `$libtool --version |
                       sed 1q |
                       grep 'GNU libtool' 2>/dev/null`;
      if ($? == 0)
        {
          chomp $version;
          verbose 2, "using GNU Libtool: $libtool: $version\n";
          return $libtool;
        }
    }
  verbose 2, "did not find GNU Libtool as: @libtool\n";
}


# instrument_prefix($mode, @argv)
# -------------------------------
sub instrument ($@)
{
  my ($mode, @argv) = @_;
  my @res = @argv;

  # No instrumentation required.
  return @res
    if $mode == mode_none;

  # The type of the program to instrument.
  my $type = exists $argv[0] ? file_type $argv[0] : '';

  # Instrument if required, or if not a script.
  return @res
    unless $force || $type !~ /script/;

  # If it's a libtool wrapper, don't instrument it unless we can find
  # libtool.
  my $libtool = $type =~ /libtool wrapper/ ? find_gnu_libtool : undef;

  # Really instrument here.
  verbose 2, "mode: $mode: $mode_name{$mode}\n";
  unshift @res, instrument_prefix($mode);

  # Now, if this requires libtool, pass it.
  unshift @res, $libtool, "--mode=execute"
    if $libtool;

  return @res;
}

######################################################################

=item C<shellescape($str)>

Return C<$str> properly escaped for a regular Bourne shell.  Avoid
useless quotes to produce a readable result.

=cut

sub shellescape($)
{
  my ($str) = @_;
  $str =~ s,',\\',g;
  $str = "'$str'"
    if $str =~ m([^-+_/.[:alnum:]]);
  return $str;
}

## ------ ##
## Main.  ##
## ------ ##

getopt;
compute_mode
  if $mode == mode_auto;
my @res = instrument($mode, @ARGV);
@res = map { shellescape($_); } @res;
verbose 2, "result: @res\n";
print "@res\n";


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
