#! /usr/bin/env python
#
# Fix MSVC CPP output so that it #line refers to the Unix filenames.
# It only output "#line" once for each file, and nothing else.
#

import os, re, sys
from pysqlite2 import dbapi2 as sqlite

# Use a persistent store for Windows to Unix path translation so that it is
# shared between various processes, with proper locking, without spawning too
# many processes.
db = sqlite.connect("win2unix.db")

# Create tables if they do not exist
try:
  db.execute("create table dirs (windows varchar not null primary key, unix varchar)")
except:
  pass
try:
  db.execute("create table files (windows varchar not null primary key, unix varchar)")
except:
  pass

def real_path(dir):
  # If translation exists in db, use it
  r = list(db.execute("select unix from dirs where windows=?", (dir,)))
  if r:
    return r[0][0]
  # Spawn a sub-shell to get it and cache the result
  res = os.popen("cd %s && /bin/pwd" % dir).read().rstrip("\n")
  try:
    db.execute("insert into dirs values (?, ?)", (dir, res))
  except:
    pass
  return res

def transform(path):
  # If translation exists in db, use it
  r = list(db.execute("select unix from files where windows=?", (path,)))
  if r:
    return r[0][0]
  # Spawn a sub-shell to get it
  f = os.popen("winepath -u %s" % path, "r")
  res = f.read().rstrip("\r\n")
  # Translate the directory and cache the result
  res = os.path.join(real_path(os.path.dirname(res)), os.path.basename(res))
  try:
    db.execute("insert into files values (?, ?)", (path, res))
  except:
    pass
  return res

_line = re.compile('#line (\d+) "(.*)"')

seen = {}
for l in sys.stdin:
  x = _line.match(l)
  if x:
    origin = x.group(2)
    if origin not in seen:
      seen[origin] = transform(origin)
r = [f for f in seen.values() if not f.startswith('/home/build/local_wine')]
r.sort
# Output all the files only once. Two different Windows file names may
# in fact correspond to the same Unix file name, for example if the
# path contains redundant "." components. We use a hash-table here for speed.
output = {}
for f in r:
  try:
    # Use a filename only if it exists as a real file and if we haven't seen
    # it before.
    os.stat(f)
    if f not in output:
      print '#line 1 "%s"' % f
    output[f] = True
  except:
    pass
try:
  db.commit()
except:
  pass
