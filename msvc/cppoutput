#! /usr/bin/env python
#
# Fix MSVC CPP output so that it #line refers to the Unix filenames.
# It only output "#line" once for each file, and nothing else.
#

import os, re, sys
from pysqlite2 import dbapi2 as sqlite

# Use a persistent store for Windows to Unix path translation so that it is
# shared between various processes, with proper locking, without spawning too
# many processes.
db = sqlite.connect("win2unix.db")

# Create tables if they do not exist
try:
  db.execute("create table dirs (windows varchar not null primary key, unix varchar)")
except:
  pass
try:
  db.execute("create table files (windows varchar not null primary key, unix varchar)")
except:
  pass

def real_path(dir):
  # If translation exists in db, use it
  r = list(db.execute("select unix from dirs where windows=?", (dir,)))
  if r:
    return r[0][0]
  # Spawn a sub-shell to get it and cache the result
  res = os.popen("cd %s && /bin/pwd" % dir).read().rstrip("\n")
  try:
    db.execute("insert into dirs values (?, ?)", (dir, res))
  except:
    pass
  return res

def transform(path):
  # If translation exists in db, use it
  r = list(db.execute("select unix from files where windows=?", (path,)))
  if r:
    return r[0][0]
  # Spawn a sub-shell to get it
  f = os.popen("winepath -u %s" % path, "r")
  res = f.read().rstrip("\r\n")
  # Translate the directory and cache the result
  res = os.path.join(real_path(os.path.dirname(res)), os.path.basename(res))
  try:
    db.execute("insert into files values (?, ?)", (path, res))
  except:
    pass
  return res

output = {}
seen = {}
full = "--full" in sys.argv
_line = re.compile('\s*#\s*line\s+(\d+)\s+"(.*)"')

for l in sys.stdin:
  x = _line.match(l)
  if x:
    origin = x.group(2)
    try:
      t = seen[origin]
      if not full:
	continue
    except:
      t = transform(origin)
      seen[origin] = t
    # If we have output this file already, we may not have to do it again
    if origin in output and not full:
      continue
    output[origin] = True
    # If the file does not really exist, prepend the line with "//" so that
    # we do not mess dependencies up
    try:
      os.stat(t)
    except:
      if not full:
	continue
      sys.stdout.write("//")
    sys.stdout.write('#line %s "%s"\n' % (x.group(1), t))
  elif full:
    sys.stdout.write(l)

try:
  db.commit()
except:
  pass
