#! /bin/bash

# Wrapper to use Microsoft compiler and linker under wine with
# Autotools.

set -e

case $VERBOSE in (x)
  set -x;;
esac

me=$(basename "$0")

stderr ()
{
  local i
  for i
  do
    echo >&2 "$me: $i"
  done
}

run ()
{
  verbose "run: $*"
  "$@"
}

error ()
{
  local exit=$1
  shift
  stderr "$@"
  exit $exit
}

verbose ()
{
  case " $VERBOSE " in
    (*" cl.exe "*|*" link.exe "*|" x ")
      stderr "$@"
      ;;
  esac
}

fatal ()
{
  error 1 "$@"
}

transform ()
{
  case $1 in
    (/*) winepath -w "$1";;
    (*)  echo "$1";;
  esac
}

handle_lib ()
{
  # If $systemlibs is not defined, set it up.  It saves time (and
  # traces) to do it only on demand instead of always.
  test "${systemlibs+set}" = set ||
  {
    # The libs we produce are called libfoo.lib, whereas the system
    # libs are called foo.lib.
    local lib_dirs="$HOME/.wine/winroot/boost_1_35_0/lib"
    lib_dirs+=" $VCXX_PATH/lib"
    lib_dirs+=" $VCXX_PATH/PlatformSDK/Lib"
    # On one line to make it easier to read set -x.
    systemlibs=$(find $lib_dirs -iname '*.lib' -exec basename {} ';' |
                    tr A-Z a-z |
                    sort -u |
                    tr -d '\r' |
                    tr '\n' ' ')
  }

  local base=${1#-l}.lib
  local res
  # If $base is not in $systemlibs, prepend "lib".
  case " $systemlibs " in
    (*" $base "*) res=$base;;
    (*)           res=lib$base;;
  esac
  res=$(transform $res)
  verbose "handle_lib: $1 -> $res"
  echo "$res"
}

# append VARIABLE VALUES...
# -------------------------
# Append the VALUES to $VARIABLE, making sure it has all the needed
# escapes.  Separates with spaces.
append ()
{
  local var=$1
  shift
  local val
  for val
  do
    case $val in
      (*[''""\\\\\<\>\*\;\|]*)
        # We use printf to avoid backslash-interpolation.
        val='"'$(printf '%s' "$val" | sed -e 's/[''""\\\\]/\\&/g')'"'
        ;;
    esac
    # Avoid useless spaces.
    local sep
    case $var:$val in
        (*:|:*) sep=;;
        (*)     sep=' ';;
    esac
    eval "$var+=\$sep\$val"
  done
#  eval verbose "$var=\$$var"
}

# linkargs ARG...
# ---------------
# Append to $linkargs.
linkargs ()
{
  append linkargs "$@"
}

# outargs ARG...
# --------------
# Append to $outargs.
outargs ()
{
  append outargs "$@"
}


get_options ()
{
  verbose "arguments: $*"
  while test $# -ne 0
  do
    local opt=$1
    case $1 in
    (-link) ;;
    (-dll)  linkargs "/DLL" ;;
    (-L*)   linkargs /LIBPATH:$(transform ${1#-L}) ;;
    (-l*)   linkargs $(handle_lib $1) ;;
    (*.lib) linkargs $(transform $1) ;;
    (*.a)   linkargs $(transform $(echo $1 | sed -e 's/.a$/.lib/')) ;;
    (-E)  mode=preprocess; outargs /E ;;
    (-c)  mode=compile; outargs /c ;;
    (-o)  shift
         got_output_arg=true
         output=$1
         if test "$mode" = compile || echo $1 | egrep -q '(.o|.obj)$'; then
           outargs /Fo$(transform $1)
         else
           case $PROG in
             (link.exe) outargs /OUT:$(transform $1);;
             (*)        outargs /Fe$(transform $1);;
           esac
           linkargs "/SUBSYSTEM:console" "/MANIFEST" "kernel32.lib"
         fi
         # if echo $1 | grep -q .exe; then PROG=link.exe ; fi
        ;;
    (-Wno-unused-parameter) ;;
    (-g|-ggdb) ;; # outargs "/Zi";;
    (-O2|-O3) outargs /O2;;
    (-f*)  ;;
    (*.dll)
      outargs $(transform $(echo $1 | sed -re 's/(-[0-9]*)?.dll/.lib/')) ;;
    (*.S)  outargs "/TP" "$1";;
    (*.c|*.cc) outargs $(transform $1); source=$1  ;;
    (*.i|*.ii) outargs "/TP" "$(transform $1)"; source=$1  ;;
    (*)  outargs $1;;
    esac
    shift
  done
}

dos2unix ()
{
  # Sed is easier to use than tr, which works on stdin only.
  sed -e 's/\r//' "$@"
}

PROG=$me

: ${TMPDIR=/tmp}
tmp=$TMPDIR/$me/$$
# trap "exit=\$?; rm -rf $tmp; exit \$exit" 0
mkdir -p $tmp
stdout=$tmp/stdout
stderr=$tmp/stderr

VCXX_PATH=$(winepath -u $VCINSTALLDIR)
VCXX_BIN=$VCXX_PATH/bin

if ! test -x $VCXX_BIN/cl.exe; then
  fatal "cl.exe not found in $VCXX_BIN"
fi

outargs=/MD
case $PROG in
  (cl.exe) outargs "/nologo" "/EHsc";;
esac

linkargs=
mode=
got_output_arg=false
source=
#output file name
output=

get_options "$@"

# handle -c without -o
if test "$mode" = compile && ! $got_output_arg; then
  obj=$(echo $source | sed -re 's/\.[^.]+$/.obj/')
  obj=$(basename "$obj")
  outargs /Fo$(transform $obj)
fi

if test "$PROG" = cl.exe && ! test -z "$linkargs"; then
  outargs "/link" $linkargs
  linkargs=
fi

verbose "mode: $mode"

if eval "run \"$VCXX_BIN/$PROG\" $outargs $linkargs" >$stdout 2>$stderr; then
  status=$?
  # Clear the \r from stderr, they are a nuisance for buildbot and
  # Emacs.
  dos2unix $stderr >&2
  # In cpp mode, the output is sent to stdout and is expected there
  # by depcomp.
  if test $mode = preprocess; then
    cppoutput <$stdout
  else
    dos2unix $stdout
  fi
else
  status=$?
  # Clear the \r from stderr, they are a nuisance for buildbot and
  # Emacs.
  dos2unix $stderr >&2
  dos2unix $stdout
  exit $status
fi

#embed manifest
#if echo $output | egrep -q '(exe|dll)$'; then
#  $VCXX_BIN/mt.exe -manifest "$(transform $output.manifest)" -outputresource:"$(transform $output);1"
#  rm "$output.manifest"
#fi

# embed manifest by compiling it into a resource to avoid mt.exe crash with
# -outputresource when using Wine
# Following procedure described at:
# http://msdn.microsoft.com/fr-fr/library/ms235591.aspx
case $output in
  (*exe|*dll)
  #$VCXX_BIN/mt.exe -manifest "$(transform $output).manifest" "-out:$(transform $output).auto.manifest"
  # Escape quotes
  sed -e 's/"/""/g' < "$output.manifest" > "$output.escaped.manifest"
  cat > "$output.auto.rc" << __EOF__
#include <winuser.h>
1 RT_MANIFEST {"$(cat $output.escaped.manifest)"}
__EOF__
  run $VCXX_BIN/rc.exe /r "$(transform $output).auto.rc"
  eval run "$VCXX_BIN/$PROG $outargs $linkargs \"$(transform $output).auto.RES\""
  ;;
esac

# Rename .lib with a versioned name.
case $output in
 (*-[0-9.]*.dll)
  libname=$(echo $output | sed -e 's/dll$/lib/')
  if test -f "$libname"; then
    run mv -f $libname $(echo $output | sed -re 's/-[0-9.]+\.dll/.lib/')
  fi
  ;;
esac
