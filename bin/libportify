#! /usr/bin/perl -w

use strict;
use IO::File;
use File::Basename;

# A regexp that matches 0 or more repetitions of either a
# non-backtracking word with no parens/braces, or a braced group, or a
# parenthezied group.
#
# Note that since it is greedy and non-backtracking, it might eat too
# much.  Use $braced instead.
my $balanced;
$balanced =
  qr{
       (?:
          (?> [^(){}\[\]]+ )         # Non-parens/braces without backtracking
        |
          \( (??{ $balanced }) \)     # Group with matching parens
        |
          \{ (??{ $balanced }) \}     # Group with matching braces
        |
          \[ (??{ $balanced }) \]     # Group with matching brackets
       )*
    }x;

# Same as above, but allow backtracking on non-braced parts, so that
# we don't eat places where we want to catch operators.
my $braced =
  qr{
      (?:
          \{ $balanced \}
        | \( $balanced \)
        | \[ $balanced \]
        | [^(){}\[\]]+        # Non-parens/braces with backtracking
      )*
    }x;


# contents ($FILE_NAME)
# ---------------------
sub contents ($)
{
  my ($file) = @_;
  local $/;                     # Turn on slurp-mode.
  use IO::File;
  my $f = new IO::File "< $file" or die "cannot open $file: $!";
  my $contents = $f->getline or die "cannot read $file: $!";
  $f->close;
  return $contents;
}


## ------------- ##
## fix headers.  ##
## ------------- ##

# fix_headers ($FILE, \$CONTENTS)
# ------------------------------
# Normalize the use of libport and system headers.
sub fix_headers ($\$)
{
  my ($file, $contents_ref) = @_;
  local $_ = $$contents_ref;

  # C-system headers.
  s{include\s*<
    (assert
    |ctype
    |errno
    |limits
    |locale
    |math
    |setjmp
    |signal
    |stdarg
    |stddef
    |stdio
    |stdint
    |stdlib
    |string
    |time
    ).h>}
   {include <c$1>}gx;

  # Libport headers.
  # FIXME: Compute this list.
  s{<(cassert
     |cerrno
     |cmath
     |csignal
     |cstdio
     |cstdlib
     |cstring
     |ctime
     |fcntl.h
     |pthread.h
     |semaphore.h
     |unistd.h
     |sys/param.h
     |sys/prctl.h
     |sys/select.h
     |sys/socket.h
     |sys/stat.h
     |sys/time.h
     |sys/wait.h
     |sys/types.h)>}
  {
    my $header = $1;
    # System header wrappers must include system headers, they must not
    # be converted to including themselves.
    $file =~ $header ? "<$header>" : "<libport/$header>"
  }gxe;

  # Some Boost headers have a version in Libport that avoids warnings.
  s{<boost/(bind|lexical_cast|format).hpp>}
   {
     my $header = $1;
     # We use -, they use _.
     (my $dash_header = $header) =~ tr/_/-/;
     $file =~ $dash_header ? "<boost/$header.hpp>" : "<libport/$dash_header.hh>";
   }gxe;

  $$contents_ref = $_;
}

## --------------- ##
## libport.debug.  ##
## --------------- ##

# to_format $STREAM
# -----------------
# Take a C++ stream content sequence without the stream itself
# and return a format string and arguments.
#
# For instance
#
#    "this is a message"
#    => ("this is a message", "")
#    "this is a message " << foo << ": " << bar
#    => ("this is a message %s: %s", "(foo)(bar)")
sub to_format ($)
{
  my ($stream) = @_;
  my $res = "";
  my @arg;
  for my $c (split(/\s*<<\s*/, $stream))
  {
      $c =~ s/^\s+//;
      $c =~ s/\s+$//;
      if ($c =~ /^"(.*)"$/ || $c =~ /^'(.*)'$/)
      {
          $res .= $1;
      }
      else
      {
          $res .= "%s";
          push @arg, $c
      }
  }
  my $args = join ', ', @arg;
  return ("\"$res\"", $args);
}

# gdebug($CATEGORY, [$FORMAT, $ARGS])
# -----------------------------------
sub gdebug($@)
{
  my ($category, ($format, $args)) = @_;
  if ($args)
  {
    return "GD_F$category($format, $args)";
  }
  else
  {
    return "GD_$category($format)";
  }
}

# trace_num_to_category($NUM)
# ---------------------------
# TRACE is used for informative messages.  Bounce to INFO.
sub trace_num_to_category ($)
{
  my ($num) = @_;
  my @cat = ("log", "trace", "debug", "dump");
  my $res = $cat[$num] || "dump";
  return "INFO_" . uc $res;
}

# libport_debug ($FILE, \$CONTENTS)
# --------------------------------
# Convert from gdebug.hh to Libport.Debug.
sub libport_debug ($\$)
{
  my ($file, $contents_ref) = @_;
  local $_ = $$contents_ref;

  # TRACE(0, "foo: " << foo);
  s{TRACE\s*\((\d),\s*(.*?)\)}
   {gdebug(trace_num_to_category($1), to_format($2))}ges;

  # DEBUG_LOG("-> Remote") << "askForStreamDestruction (" << cnx_id << ")" << std::endl;
  # DEBUG_LOG(session_id)  << std::endl;
  # DEBUG_LOG(session_id) << "parseRTSPUrl: "<< e.what ();
  s{DEBUG_LOG\s*\((.*?)\)(.*?)(?:\s*<<\s*std::endl)?\s*;}
   {gdebug("INFO_LOG", to_format("'[' << $1 << \"] \" $2")) . ";";}ges;

  # Move from "Format, (Arg1)(Arg2)" to "Format, Arg1, Arg2"...
  s{
    ([ \t]*)
    (GD_F(?:INFO(?:_LOG|_TRACE|_DEBUG|_DUMP)?|WARN|ERROR|PUSH|ABORT))
    \(
      (".*?"),\s*
      ((?:\($balanced+\)\s*)+)
    \)
   }
   {
     my $spaces = $1;
     my $channel = $2;
     my $format = $3;
     my $args = $4;
     my @arg = ($format);
     $args =~ s/\(($balanced+)\)\s*/push @arg, $1/ges;

     # Chose the separator: if fits on a single line, simply ','.
     # Otherwise, indeed each argument on its line.
     my $tab = $spaces . " " x length("$channel(");
     my $res = $spaces . "$channel(" . (join ", ", @arg) . ")";
     $res = $spaces . "$channel(" . (join ",\n$tab", @arg) . ")"
       if 76 < length $res;
     $res;
   }xges;


  $$contents_ref = $_;
}

# libport_renamings ($FILE, \$CONTENTS)
# -------------------------------------
# Convert old symbol names to new names.
sub libport_renamings ($\$)
{
  my ($file, $contents_ref) = @_;
  local $_ = $$contents_ref;

  # We are now simply using Boost.Unordered.
  s/libport::hash_map/boost::unordered_map/g;

  $$contents_ref = $_;
}


## ----------- ##
## transform.  ##
## ----------- ##


# libportify ($FILE, $CONTENTS)
# -----------------------------
sub libportify ($$)
{
  my ($file, $contents) = @_;
  fix_headers $file, $contents;
  libport_debug $file, $contents;
  libport_renamings $file, $contents;
  return $contents;
}

# transform_file (&TRANSFORM, $FILE)
# ----------------------------------
sub transform_file (\&$)
{
  my ($transform_ref, $file) = @_;

  # When using globbing, we sometimes find directories.
  if (! -f $file)
  {
    warn "ignoring non file: $file";
    return;
  }

  # When using globbing, we sometimes find directories.
  if ($file =~ /\.bak$/)
  {
    warn "ignoring backup file: $file";
    return;
  }

  my $contents = contents ($file);
  my $updated = $transform_ref->($file, $contents);
  if ($contents ne $updated)
    {
      my ($bak) = "$file.bak";
      rename ($file, $bak) or die "cannot rename $file as $bak: $!";
      my $out = new IO::File(">$file") or die;
      print $out $updated;
      $out->close;
      system("colordiff -u $bak $file");
    }
  else
    {
      warn "no changes: $file\n";
    }
}


# transform_things (&TRANSFORM, @THING)
# ------------------------------------
# Work on file-system entities.
sub transform_things (\&@)
{
  my ($transform_ref, @thing) = @_;

  for my $thing (@thing)
    {
      if (
          -f $thing
          # We libportify source files.  They have an extension,
          # except cstdio and so forth...
          && basename($thing) =~ m{ (?:\.(?:cc|hh|h|hxx)$)
                                  | (?:^c\w+$)}x
          # but then configure matches that regexp.
          && basename($thing) !~ m{configure}x
        )
        {
          transform_file &$transform_ref, $thing;
        }
      elsif (-d $thing
             && $thing !~ m{(?:libltdl
                              |libcoroutine
                              |\.git
                              |\.dsym
                              |bison
                              |_build
                              |jpeg)$}x)
        {
          opendir (my $dir, $thing) ||
            die "cannot opendir $thing: $!";
          my @e = map { "$thing/$_" } grep { !/^\.\.?$/ } readdir($dir);
          transform_things ($transform_ref, @e);
          closedir $dir;
        }
      else
        {
          warn (-e $thing
                ? "skipping $thing\n"
                : "ignoring $thing: does not exist\n");
        }
    }
}

## ------ ##
## main.  ##
## ------ ##

transform_things &libportify, @ARGV;


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
