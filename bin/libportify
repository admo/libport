#! /usr/bin/perl -w

use strict;
use IO::File;
use File::Basename;

# contents ($FILE_NAME)
# ---------------------
sub contents ($)
{
  my ($file) = @_;
  local $/;                     # Turn on slurp-mode.
  use IO::File;
  my $f = new IO::File "< $file" or die "cannot open $file: $!";
  my $contents = $f->getline or die "cannot read $file: $!";
  $f->close;
  return $contents;
}


## ------------- ##
## fix headers.  ##
## ------------- ##

# fix_headers ($FILE, \$CONTENTS)
# ------------------------------
# Normalize the use of libport and system headers.
sub fix_headers ($\$)
{
  my ($file, $contents_ref) = @_;
  local $_ = $$contents_ref;

  # C-system headers.
  s{include\s*<
    (assert
    |ctype
    |errno
    |limits
    |locale
    |math
    |setjmp
    |signal
    |stdarg
    |stddef
    |stdio
    |stdint
    |stdlib
    |string
    |time
    ).h>}
   {include <c$1>}gx;

  # Libport headers.
  # FIXME: Compute this list.
  s{<(cassert
     |cerrno
     |cmath
     |csignal
     |cstdio
     |cstdlib
     |cstring
     |ctime
     |fcntl.h
     |pthread.h
     |semaphore.h
     |unistd.h
     |sys/param.h
     |sys/prctl.h
     |sys/select.h
     |sys/socket.h
     |sys/stat.h
     |sys/time.h
     |sys/wait.h
     |sys/types.h)>}
  {
    my $header = $1;
    # System header wrappers must include system headers, they must not
    # be converted to including themselves.
    $file =~ $header ? "<$header>" : "<libport/$header>"
  }gxe;

  # Some Boost headers have a version in Libport that avoids warnings.
  s{<boost/(bind|lexical_cast|format).hpp>}
   {
     my $header = $1;
     # We use -, they use _.
     (my $dash_header = $header) =~ tr/_/-/;
     $file =~ $dash_header ? "<boost/$header.hpp>" : "<libport/$dash_header.hh>";
   }gxe;

  $$contents_ref = $_;
}

## --------------- ##
## libport.debug.  ##
## --------------- ##

# to_format $STREAM
# -----------------
# Take a C++ stream content sequence without the stream itself
# and return a format string and arguments.
#
# For instance
#
#    "this is a message"
#    => ("this is a message", "")
#    "this is a message " << foo << ": " << bar
#    => ("this is a message %s: %s", "(foo)(bar)")
sub to_format ($)
{
  my ($stream) = @_;
  my $res = "";
  my @arg;
  for my $c (split(/\s*<<\s*/, $stream))
  {
      $c =~ s/^\s+//;
      $c =~ s/\s+$//;
      if ($c =~ /^"(.*)"$/ || $c =~ /^'(.*)'$/)
      {
          $res .= $1;
      }
      else
      {
          $res .= "%s";
          push @arg, $c
      }
  }
  my $args = join '', map { "($_)" } @arg;
  return ("\"$res\"", $args);
}

# gdebug($CATEGORY, [$FORMAT, $ARGS])
# -----------------------------------
sub gdebug($@)
{
  my ($category, ($format, $args)) = @_;
  if ($args)
  {
    return "GD_F$category($format, $args)";
  }
  else
  {
    return "GD_$category($format)";
  }
}

# trace_num_to_category($NUM)
# ---------------------------
# TRACE is used for informative messages.  Bounce to INFO.
sub trace_num_to_category ($)
{
  my ($num) = @_;
  my @cat = ("log", "trace", "debug", "dump");
  my $res = $cat[$num] || "dump";
  return "INFO_" . uc $res;
}

# libport_debug ($FILE, \$CONTENTS)
# --------------------------------
# Convert from gdebug.hh to Libport.Debug.
sub libport_debug ($\$)
{
  my ($file, $contents_ref) = @_;
  local $_ = $$contents_ref;

  # TRACE(0, "foo: " << foo);
  s{TRACE\s*\((\d),\s*(.*?)\)}
   {gdebug(trace_num_to_category($1), to_format($2))}ges;

  # DEBUG_LOG("-> Remote") << "askForStreamDestruction (" << cnx_id << ")" << std::endl;
  # DEBUG_LOG(session_id)  << std::endl;
  # DEBUG_LOG(session_id) << "parseRTSPUrl: "<< e.what ();
  s{DEBUG_LOG\s*\((.*?)\)(.*?)(?:\s*<<\s*std::endl)?\s*;}
   {gdebug("INFO_LOG", to_format("'[' << $1 << \"] \" $2")) . ";";}ges;

  $$contents_ref = $_;
}



## ----------- ##
## transform.  ##
## ----------- ##


# libportify ($FILE, $CONTENTS)
# -----------------------------
sub libportify ($$)
{
  my ($file, $contents) = @_;
  fix_headers $file, $contents;
  libport_debug $file, $contents;
  return $contents;
}

# transform_file (&TRANSFORM, $FILE)
# ----------------------------------
sub transform_file (\&$)
{
  my ($transform_ref, $file) = @_;

  # When using globbing, we sometimes find directories.
  if (! -f $file)
  {
    warn "ignoring non file: $file";
    return;
  }

  # When using globbing, we sometimes find directories.
  if ($file =~ /\.bak$/)
  {
    warn "ignoring backup file: $file";
    return;
  }

  my $contents = contents ($file);
  my $updated = $transform_ref->($file, $contents);
  if ($contents ne $updated)
    {
      my ($bak) = "$file.bak";
      rename ($file, $bak) or die "cannot rename $file as $bak: $!";
      my $out = new IO::File(">$file") or die;
      print $out $updated;
      $out->close;
      system("colordiff -u $bak $file");
    }
  else
    {
      warn "no changes: $file\n";
    }
}

# transform_things (&TRANSFORM, @THING)
# ------------------------------------
# Work on file-system entities.
sub transform_things (\&@)
{
  my ($transform_ref, @thing) = @_;

  for my $thing (@thing)
    {
      if (-f $thing
          && basename($thing) =~ m{ (?:\.(?:cc|hh|h|hxx)$)
                                  | (?:^c\w+$)}x)
        {
          transform_file &$transform_ref, $thing;
        }
      elsif (-d $thing
             && $thing !~ m{(?:libltdl
                              |libcoroutine
                              |\.git
                              |\.dsym
                              |bison
                              |jpeg)$}x)
        {
          opendir (my $dir, $thing) ||
            die "cannot opendir $thing: $!";
          my @e = map { "$thing/$_" } grep { !/^\.\.?$/ } readdir($dir);
          transform_things ($transform_ref, @e);
          closedir $dir;
        }
      else
        {
          warn (-e $thing
                ? "skipping $thing\n"
                : "ignoring $thing: does not exist\n");
        }
    }
}

## ------ ##
## main.  ##
## ------ ##

transform_things &libportify, @ARGV;


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
